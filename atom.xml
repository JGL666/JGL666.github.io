<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgl666.github.io</id>
    <title>JGL</title>
    <updated>2020-06-26T06:41:14.688Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgl666.github.io"/>
    <link rel="self" href="https://jgl666.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgl666.github.io/images/avatar.png</logo>
    <icon>https://jgl666.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JGL</rights>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列2]]></title>
        <id>https://jgl666.github.io/post/quiz/</id>
        <link href="https://jgl666.github.io/post/quiz/">
        </link>
        <updated>2020-06-26T06:40:45.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/2">原文链接</a></p>
<h2 id="问题br">问题<br></h2>
<pre><code>struct S(i32);

impl std::ops::BitAnd&lt;S&gt; for () {
    type Output = ();

    fn bitand(self, rhs: S) {
        print!(&quot;{}&quot;, rhs.0);
    }
}

fn main() {
    let f = || ( () &amp; S(1) );
    let g = || { () &amp; S(2) };
    let h = || ( {} &amp; S(3) );
    let i = || { {} &amp; S(4) };
    f();
    g();
    h();
    i();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>（）是分组表达式，结果是整个括号内部计算的结果，是一条表达式语句。<br><br>
闭包返回的是一个分组表达式，计算结果为括号内部的计算结果。即调用bitand输出1</p>
<pre><code> let f = || ( () &amp; S(1) );
</code></pre>
<br>
<h4 id="no2">NO.2</h4>
<hr>
<p>块表达式语句中只有一条表达式语句，计算结果就是() &amp; S(2)结果，即调用bitand输出2</p>
<pre><code> let g = || { () &amp; S(2) };
</code></pre>
<br>
<h4 id="no3">NO.3</h4>
<hr>
<p>闭包返回一个<a href="https://doc.rust-lang.org/reference/expressions/grouped-expr.html">分组表达式</a>。</p>
<pre><code>let h = || ( {} &amp; S(3) );
</code></pre>
<p>拿掉外面的()，计算如下表达式</p>
<pre><code> {} &amp; S(3)
</code></pre>
<p>因为{}是一个块表达式，默认返回单元类型(),所以最终相当于计算</p>
<pre><code>() &amp; S(3)
</code></pre>
<p>最后输出3</p>
<br>
<h4 id="no4">NO.4</h4>
<hr>
<p>闭包返回的是块表达式，块表达式是按顺序执行表达式中的语句。</p>
<pre><code> let i = || { {} &amp; S(4) };
</code></pre>
<p>该块表达式一共有两条语句，一条是{}<a href="https://doc.rust-lang.org/reference/expressions/block-expr.html">块表达式语句</a>，另一条是<a href="https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions">位置表达式语句</a>。因为是块表达式的最后一句，作为块表达式的返回值，<mark>本来表达式作为语句需要加分号，现在不用加了</mark>。<br><br>
所以执行流程如下</p>
<pre><code>let i = || { 
{};
return &amp;S(4); };
</code></pre>
<p>最后返回&amp;S(4),什么输出也没有。</p>
<br>
<h2 id="rust相关知识点">Rust相关知识点</h2>
<ul>
<li><strong>关联类型</strong><br><br>
关联类型是一个占位符，trait在方法签名的时候，暂时使用它来表示抽象的类型，<br>
等到具体实现的时候指定具体的类型。<br></li>
</ul>
<p>   <strong>和泛型比较：</strong><br><br>
   <strong>相同</strong>：关联类型和泛型一样都是延迟对trait使用具体类型的决定。<br><br>
   <strong>不同</strong>：当一个trait有一个泛型参数时，它可以为一个类型实现多次，每次更改泛型类型参数的具体类型。关联类型只能实现一次。<br></p>
<p>   <strong>泛型示例</strong></p>
<pre><code>impl From&lt;(i32,i32)&gt; for Pointer{
    fn from(val:(i32,i32))-&gt;Pointer{
        Pointer{x:val.0, y:val.1}
    }
}


impl From&lt;i32&gt; for Pointer{
    fn from(val:i32)-&gt;Pointer{
        Pointer{x:val, y:val}
    }
}
</code></pre>
<p>   <strong>关联类型示例</strong></p>
<pre><code>impl Iterator for Pointer{
    type Item = i32;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;{
        None
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列1]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-1/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-1/">
        </link>
        <updated>2020-06-26T01:30:10.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/1">原文链接</a></p>
<h2 id="问题">问题</h2>
<pre><code>macro_rules! m {
    ($($s:stmt)*) =&gt; {
        $(
            { stringify!($s); 1 }
        )&lt;&lt;*
    };
}

fn main() {
    print!(
        &quot;{}{}{}&quot;,
        m! { return || true },
        m! { (return) || true },
        m! { {return} || true },
    );
}
</code></pre>
<br>
<h2 id="解析">解析</h2>
<h4 id="no1">NO1</h4>
<hr>
<p>表示匹配一个或者多个Rust语句</p>
<pre><code>($($s:stmt)*)
</code></pre>
<p>这是Rust匹配宏规则，stmt表示语句</p>
<pre><code>$s:stmt
</code></pre>
<h4 id="no2">NO2</h4>
<hr>
<p>Rust在宏中引用$s，表示引用匹配的变量。<br><br>
stringify!将引用的token转为字符串</p>
<pre><code>{ stringify!($s); 1 }
</code></pre>
<h4 id="no3">NO3</h4>
<hr>
<p>return || true 是一个表达式语句 返回一个闭包</p>
<pre><code> m! { return || true }
</code></pre>
<p>如下代码一样</p>
<pre><code>fn main() {
    fn get_f()-&gt;fn()-&gt;bool{
        return || true;
    }
    let f: fn()-&gt;bool = get_f();
    //true
    println!(&quot;{}&quot;,f());
}
</code></pre>
<h4 id="no4">NO4</h4>
<hr>
<p>(return) || true 是一个逻辑或表达式语句<br><br>
这里面都是表达式，整体作为一个表达式语句</p>
<pre><code> m! { (return) || true }
</code></pre>
<h4 id="no5">NO5</h4>
<hr>
<p>左边是一个块表达式语句，右边是一个闭包表达式语句<br><br>
这是两个语句</p>
<pre><code>m! { {return} || true }
</code></pre>
<br>
<h2 id="rust相关知识点">Rust相关知识点</h2>
<ul>
<li>Rust中的语句<br><br>
<a href="https://doc.rust-lang.org/reference/statements.html">官方文档</a><br><br>
<img src="https://jgl666.github.io/post-images/1593149001372.PNG" alt="" loading="lazy"><br>
<a href="https://doc.rust-lang.org/reference/items.html">Item</a>是包的组件，包括模块、函数、结构体等等。<br><br>
块表达式语句可以没有分号，例如{}或者unsafe{}都是块表达式语句。<br><br>
()是<a href="https://doc.rust-lang.org/reference/expressions/grouped-expr.html">分组表达式</a>，返回分组计算的结果。</li>
</ul>
]]></content>
    </entry>
</feed>