<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgl666.github.io</id>
    <title>JGL</title>
    <updated>2020-07-07T09:43:49.653Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgl666.github.io"/>
    <link rel="self" href="https://jgl666.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgl666.github.io/images/avatar.png</logo>
    <icon>https://jgl666.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JGL</rights>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列24]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-24/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-24/">
        </link>
        <updated>2020-07-07T09:43:14.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/21">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<hr>
<pre><code>fn main() {
    let x: u8 = 1;
    const K: u8 = 2;

    macro_rules! m {
        () =&gt; {
            print!(&quot;{}{}&quot;, x, K);
        };
    }

    {
        let x: u8 = 3;
        const K: u8 = 4;

        m!();
    }
}
</code></pre>
<h2 id="解析">解析</h2>
<p>Rust宏是部分卫生的，参看<a href="https://danielkeep.github.io/tlborm/book/mbe-min-hygiene.html">卫生宏</a><br><br>
本题中宏中x先被替换为1，后面括号内的x不会影响宏中的x。const 在Rust中一个Item，不是本地变量，在出现K的地方会被替换为对应的值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列23]]></title>
        <id>https://jgl666.github.io/post/jjjj/</id>
        <link href="https://jgl666.github.io/post/jjjj/">
        </link>
        <updated>2020-07-07T09:41:49.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/23">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<hr>
<pre><code>trait Trait {
    fn f(&amp;self);
    fn g(&amp;self);
}

struct S;

impl S {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }

    fn g(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for S {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }

    fn g(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    S.f();
    S.g();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>如果结构体方法和trait中方法重名，默认调用结构体自身的方法。可以使用消除歧义的语法调用trait中的方法。</p>
<pre><code>&lt;S as Trait&gt;::f(&amp;S);
</code></pre>
<p>NO.2</p>
<hr>
<p>S找不到方法，会添加引用，找到Trait中定义的方法</p>
<pre><code>fn g(&amp;self) {
    print!(&quot;2&quot;);
}
</code></pre>
<h4 id="no3">NO.3</h4>
<hr>
<p>如果还是找不到就加上&amp;mut<br>
这里注释掉，输出11</p>
<pre><code>impl Trait for S {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }

    fn g(&amp;self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<h4 id="no4">NO.4</h4>
<hr>
<p>增加新的Trait1，输出33，因为直接匹配到方法中接受类型就是S</p>
<pre><code>trait Trait1{
    fn f(self);
    fn g(self);
}

impl Trait1 for S {
    fn f(self) {
        print!(&quot;3&quot;);
    }

    fn g(self) {
        print!(&quot;3&quot;);
    }
}
</code></pre>
<h4 id="no5">NO.5</h4>
<hr>
<p>这样也可以，输出1，3</p>
<pre><code>trait Trait {
    fn f(&amp;self);
    fn g(&amp;self);
}

struct S;

impl S {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }

    fn g(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

// impl Trait for S {
//     fn f(&amp;self) {
//         print!(&quot;2&quot;);
//     }
//
//     fn g(&amp;self) {
//         print!(&quot;2&quot;);
//     }
// }

trait Trait1{
    fn f(self);
    fn g(self);
}

impl Trait1 for &amp;S {
    fn f(self) {
        print!(&quot;3&quot;);
    }

    fn g(self) {
        print!(&quot;3&quot;);
    }
}
fn main() {
    S.f();
    S.g();
}
</code></pre>
<h4 id="no5-2">NO.5</h4>
<hr>
<p>这里输出33，没找到先解引用</p>
<pre><code>trait Trait {
    fn f(&amp;self);
    fn g(&amp;self);
}

struct S;

// impl S {
//     fn f(&amp;self) {
//         print!(&quot;1&quot;);
//     }
//
//     fn g(&amp;mut self) {
//         print!(&quot;1&quot;);
//     }
// }

impl Trait for S {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }

    fn g(&amp;self) {
        print!(&quot;2&quot;);
    }
}

trait Trait1{
    fn f(self);
    fn g(self);
}

impl Trait1 for S {
    fn f(self) {
        print!(&quot;3&quot;);
    }

    fn g(self) {
        print!(&quot;3&quot;);
    }
}
fn main() {
    &amp;S.f();
    &amp;S.g();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列22]]></title>
        <id>https://jgl666.github.io/post/aaaaaaa/</id>
        <link href="https://jgl666.github.io/post/aaaaaaa/">
        </link>
        <updated>2020-07-07T09:41:13.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/22">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<hr>
<pre><code>macro_rules! m {
    ($a:tt) =&gt; { print!(&quot;1&quot;) };
    ($a:tt $b:tt) =&gt; { print!(&quot;2&quot;) };
    ($a:tt $b:tt $c:tt) =&gt; { print!(&quot;3&quot;) };
    ($a:tt $b:tt $c:tt $d:tt) =&gt; { print!(&quot;4&quot;) };
    ($a:tt $b:tt $c:tt $d:tt $e:tt) =&gt; { print!(&quot;5&quot;) };
    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt) =&gt; { print!(&quot;6&quot;) };
    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt $g:tt) =&gt; { print!(&quot;7&quot;) };
}

fn main() {
    m!(-1);
    m!(-1.);
    m!(-1.0);
    m!(-1.0e1);
    m!(-1.0e-1);
}
</code></pre>
<h2 id="解析">解析</h2>
<p>Rust中将-理解为单独的符号，小数点以及后面的e都是一个符号。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列21]]></title>
        <id>https://jgl666.github.io/post/ccc/</id>
        <link href="https://jgl666.github.io/post/ccc/">
        </link>
        <updated>2020-07-07T09:40:44.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/21">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<hr>
<pre><code>trait Trait {
    fn f(&amp;self);
}

impl&lt;F: FnOnce() -&gt; bool&gt; Trait for F {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for () {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let x = || { (return) || true; };
    x().f();

    let x = loop { (break) || true; };
    x.f();

    let x = || { return (|| true); };
    x().f();

    let x = loop { break (|| true); };
    x.f();

    let x = || { return || true; };
    x().f();

    let x = loop { break || true; };
    x.f();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>这个闭包返回(),因为(return) || true;return 是never类型, 即！可以转换为任何类型，这里会转为bool。最后， 这是一个表达式语句，外面是块表达式，最后返回（）</p>
<pre><code>let x = || { (return) || true; };
x().f();
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>这里break 跳出循环，隐式返回（）</p>
<pre><code>let x = loop { (break) || true; };
x.f();
</code></pre>
<h4 id="no3">NO.3</h4>
<p>return 返回闭包</p>
<pre><code>let x = || { return (|| true); };
x().f();
</code></pre>
<h4 id="no4">NO.4</h4>
<p>括号的优先级大于break，执行括号表达式，break 返回闭包</p>
<pre><code>let x = loop { break (|| true); };
x.f();

</code></pre>
<h4 id="no5">NO.5</h4>
<p>返回闭包</p>
<pre><code>let x = || { return || true; };
x().f();
</code></pre>
<h4 id="no6">NO.6</h4>
<p>返回闭包</p>
<pre><code>let x = loop { break || true; };
x.f();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列20]]></title>
        <id>https://jgl666.github.io/post/zzzz/</id>
        <link href="https://jgl666.github.io/post/zzzz/">
        </link>
        <updated>2020-07-07T09:38:03.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/20">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>fn return1() {
    if (return { print!(&quot;1&quot;) }) {
    }
}

fn return2() {
    if return { print!(&quot;2&quot;) } {
    }
}

fn break1() {
    loop {
        if (break { print!(&quot;1&quot;) }) {
        }
    }
}

fn break2() {
    loop {
        if break { print!(&quot;2&quot;) } {
        }
    }
}

fn main() {
    return1();
    return2();
    break1();
    break2();
}
</code></pre>
<h2 id="解析">解析</h2>
<p>参照<a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">表达式优先级</a><br></p>
<h4 id="no1">NO.1</h4>
<hr>
<p>return 总是优化处理后面的表达式</p>
<pre><code>fn return1() {
    if (return { print!(&quot;1&quot;) }) {
    }
}

fn return2() {
    if return { print!(&quot;2&quot;) } {
    }
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>() 优先级大于break，先计算括号表达式，输出1</p>
<pre><code>fn break1() {
    loop {
        if (break { print!(&quot;1&quot;) }) {
        }
    }
}
</code></pre>
<h4 id="no3">NO.3</h4>
<pre><code>fn break2() {
    loop {
        if break { print!(&quot;2&quot;) } {
        }
    }
}
</code></pre>
<p>和return 不一样，break不优先处理后面的表达式，上面的函数格式化如下。break在 {println!(&quot;2&quot;)} 之前就退出了。</p>
<pre><code>fn break2() {
    loop {
        if break
        { print!(&quot;2&quot;) }
        {}
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列19]]></title>
        <id>https://jgl666.github.io/post/aaa/</id>
        <link href="https://jgl666.github.io/post/aaa/">
        </link>
        <updated>2020-07-07T09:36:54.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/19">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>struct S;

impl Drop for S {
    fn drop(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let s = S;
    let _ = s;
    print!(&quot;2&quot;);
}
</code></pre>
<h2 id="解析">解析</h2>
<p>所有权发生转移</p>
<pre><code>let s = S;
</code></pre>
<p>所有权没有接收者，s会一直存在直到作用域结束</p>
<pre><code> let _ = s;
</code></pre>
<h4 id="拓展">拓展</h4>
<p>输出112，因为所有权没有接收者，直接drop了</p>
<pre><code>struct S;

impl Drop for S {
    fn drop(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

fn get()-&gt;S{
    S
}

fn main() {
    let _ = get();
    let _ = S;
    print!(&quot;2&quot;);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列18]]></title>
        <id>https://jgl666.github.io/post/sss/</id>
        <link href="https://jgl666.github.io/post/sss/">
        </link>
        <updated>2020-07-07T09:30:22.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/18">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>struct S {
    f: fn(),
}

impl S {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let print2 = || print!(&quot;2&quot;);
    S { f: print2 }.f();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>访问内部方法</p>
<pre><code>S { f: print2 }.f();
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>加括号显式调用闭包</p>
<pre><code> (S { f: print2 }).f();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列16和17]]></title>
        <id>https://jgl666.github.io/post/sssss/</id>
        <link href="https://jgl666.github.io/post/sssss/">
        </link>
        <updated>2020-07-07T09:12:45.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/16">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<h2 id="16">16</h2>
<pre><code>fn main() {
    let mut x = 4;
    --x;
    print!(&quot;{}{}&quot;, --x, --x);
}
</code></pre>
<p>相当于</p>
<pre><code>print!(&quot;{}{}&quot;, -(-x), -(-x));
</code></pre>
<h2 id="17">17</h2>
<p>Rust中没有--</p>
<pre><code>fn main() {
    let mut a = 5;
    let mut b = 3;
    print!(&quot;{}&quot;, a-- - --b);
}
</code></pre>
<p>上面相当于</p>
<pre><code>    let mut a = 5;
    let mut b = 3;
    print!(&quot;{}&quot;, a-(-(-(-(-b)))));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列23]]></title>
        <id>https://jgl666.github.io/post/ssss/</id>
        <link href="https://jgl666.github.io/post/ssss/">
        </link>
        <updated>2020-07-07T09:11:41.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/23">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<hr>
<pre><code>trait Trait {
    fn f(&amp;self);
    fn g(&amp;self);
}

struct S;

impl S {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }

    fn g(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for S {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }

    fn g(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    S.f();
    S.g();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>如果结构体方法和trait中方法重名，默认调用结构体自身的方法。可以使用消除歧义的语法调用trait中的方法。</p>
<pre><code>&lt;S as Trait&gt;::f(&amp;S);
</code></pre>
<p>NO.2</p>
<hr>
<p>S找不到方法，会添加引用，找到Trait中定义的方法</p>
<pre><code>fn g(&amp;self) {
    print!(&quot;2&quot;);
}
</code></pre>
<h4 id="no3">NO.3</h4>
<hr>
<p>如果还是找不到就加上&amp;mut<br>
这里注释掉，输出11</p>
<pre><code>impl Trait for S {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }

    fn g(&amp;self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<h4 id="no4">NO.4</h4>
<hr>
<p>增加新的Trait1，输出33，因为直接匹配到方法中接受类型就是S</p>
<pre><code>trait Trait1{
    fn f(self);
    fn g(self);
}

impl Trait1 for S {
    fn f(self) {
        print!(&quot;3&quot;);
    }

    fn g(self) {
        print!(&quot;3&quot;);
    }
}
</code></pre>
<h4 id="no5">NO.5</h4>
<hr>
<p>这样也可以，输出1，3</p>
<pre><code>trait Trait {
    fn f(&amp;self);
    fn g(&amp;self);
}

struct S;

impl S {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }

    fn g(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

// impl Trait for S {
//     fn f(&amp;self) {
//         print!(&quot;2&quot;);
//     }
//
//     fn g(&amp;self) {
//         print!(&quot;2&quot;);
//     }
// }

trait Trait1{
    fn f(self);
    fn g(self);
}

impl Trait1 for &amp;S {
    fn f(self) {
        print!(&quot;3&quot;);
    }

    fn g(self) {
        print!(&quot;3&quot;);
    }
}
fn main() {
    S.f();
    S.g();
}
</code></pre>
<h4 id="no5-2">NO.5</h4>
<hr>
<p>这里输出33，没找到先解引用</p>
<pre><code>trait Trait {
    fn f(&amp;self);
    fn g(&amp;self);
}

struct S;

// impl S {
//     fn f(&amp;self) {
//         print!(&quot;1&quot;);
//     }
//
//     fn g(&amp;mut self) {
//         print!(&quot;1&quot;);
//     }
// }

impl Trait for S {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }

    fn g(&amp;self) {
        print!(&quot;2&quot;);
    }
}

trait Trait1{
    fn f(self);
    fn g(self);
}

impl Trait1 for S {
    fn f(self) {
        print!(&quot;3&quot;);
    }

    fn g(self) {
        print!(&quot;3&quot;);
    }
}
fn main() {
    &amp;S.f();
    &amp;S.g();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列31]]></title>
        <id>https://jgl666.github.io/post/xxafaba/</id>
        <link href="https://jgl666.github.io/post/xxafaba/">
        </link>
        <updated>2020-07-04T07:21:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="原文链接"><a href="https://dtolnay.github.io/rust-quiz/31">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a><br><br>
<a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html#method-call-expressions">相关文档</a></h2>
<pre><code>trait Or {
    fn f(self);
}

struct T;

impl Or for &amp;T {
    fn f(self) {
        print!(&quot;1&quot;);
    }
}

impl Or for &amp;&amp;&amp;&amp;T {
    fn f(self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let t = T;
    let wt = &amp;T;
    let wwt = &amp;&amp;T;
    let wwwt = &amp;&amp;&amp;T;
    let wwwwt = &amp;&amp;&amp;&amp;T;
    let wwwwwt = &amp;&amp;&amp;&amp;&amp;T;
    t.f();
    wt.f();
    wwt.f();
    wwwt.f();
    wwwwt.f();
    wwwwwt.f();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>尝试寻找T对应的f方法，没有找到，然后给T加上&amp;，找到对应的方法</p>
<pre><code>let t = T;
t.f();
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>直接找到对应的类型&amp;T</p>
<pre><code>let wt = &amp;T;
wt.f();
</code></pre>
<h4 id="no3">NO.3</h4>
<hr>
<p>找到对应的类型&amp;&amp;T,没找到,加上&amp;,还是没有，然后解引用，找到&amp;T</p>
<pre><code>let wwt = &amp;&amp;T;
wwt.f();
</code></pre>
<h4 id="no4">NO.4</h4>
<hr>
<p>找到对应的类型&amp;&amp;&amp;T,没找到,加上&amp;,找到 &amp;&amp;&amp;&amp;T</p>
<pre><code>let wwwt = &amp;&amp;&amp;T;
wwwt.f();
</code></pre>
<h4 id="no5">NO.5</h4>
<hr>
<p>找到对应的类型&amp;&amp;&amp;T,没找到,加上&amp;,没找到,解引用找到</p>
<pre><code>let wwwwt = &amp;&amp;&amp;&amp;T;
wwwwt.f();
</code></pre>
<h4 id="no6">NO.6</h4>
<hr>
<p>找到对应的类型&amp;&amp;&amp;&amp;&amp;T,没找到,加上&amp;, 没找到,解引用找到</p>
<pre><code>let wwwwwt = &amp;&amp;&amp;&amp;&amp;T;
wwwwwt.f();
</code></pre>
]]></content>
    </entry>
</feed>