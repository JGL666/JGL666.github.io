<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgl666.github.io</id>
    <title>JGL</title>
    <updated>2020-07-02T14:59:38.675Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgl666.github.io"/>
    <link rel="self" href="https://jgl666.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgl666.github.io/images/avatar.png</logo>
    <icon>https://jgl666.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JGL</rights>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列32]]></title>
        <id>https://jgl666.github.io/post/xx/</id>
        <link href="https://jgl666.github.io/post/xx/">
        </link>
        <updated>2020-07-02T14:58:41.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/32">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<hr>
<pre><code>fn check(x: i32) -&gt; bool {
    print!(&quot;{}&quot;, x);
    false
}

fn main() {
    match (1, 2) {
        (x, _) | (_, x) if check(x) =&gt; {
            print!(&quot;3&quot;)
        }
        _ =&gt; print!(&quot;4&quot;),
    }
}
</code></pre>
<h2 id="解析">解析</h2>
<p>参看<a href="https://doc.rust-lang.org/reference/expressions/match-expr.html#match-guards">match guard</a><br><br>
上面这题的匹配过程：<br>
Rust match 匹配到 <mark>(x , _)</mark> ，此时x = 1, 然后执行 if 判断，check(x) 输出 1 , 返回false , Rust 继续匹配，匹配到 <mark>( _ , x)</mark>， 此时x = 2，再次执行 if 判断语句，返回false。继续匹配下面一条，因为 _ 是通配符，所以输出4<br><br>
流程如下图：<br>
<img src="https://jgl666.github.io/post-images/1593701933236.PNG" alt="" loading="lazy"><br>
<br></p>
<h2 id="拓展">拓展</h2>
<p>改为true 输出1 3</p>
<pre><code>fn check(x: i32) -&gt; bool {
    print!(&quot;{}&quot;, x);
    true
}

fn main() {
    match (1, 2) {
        (x, _) | (_, x) if check(x) =&gt; {
            print!(&quot;3&quot;)
        }
        _ =&gt; print!(&quot;4&quot;),
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列20]]></title>
        <id>https://jgl666.github.io/post/s/</id>
        <link href="https://jgl666.github.io/post/s/">
        </link>
        <updated>2020-07-02T05:04:42.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/15">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>fn return1() {
    if (return { print!(&quot;1&quot;) }) {
    }
}

fn return2() {
    if return { print!(&quot;2&quot;) } {
    }
}

fn break1() {
    loop {
        if (break { print!(&quot;1&quot;) }) {
        }
    }
}

fn break2() {
    loop {
        if break { print!(&quot;2&quot;) } {
        }
    }
}

fn main() {
    return1();
    return2();
    break1();
    break2();
}
</code></pre>
<h2 id="解析">解析</h2>
<p>参照<a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">表达式优先级</a><br></p>
<h4 id="no1">NO.1</h4>
<hr>
<p>return 总是优化处理后面的表达式</p>
<pre><code>fn return1() {
    if (return { print!(&quot;1&quot;) }) {
    }
}

fn return2() {
    if return { print!(&quot;2&quot;) } {
    }
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>() 优先级大于break，先计算括号表达式，输出1</p>
<pre><code>fn break1() {
    loop {
        if (break { print!(&quot;1&quot;) }) {
        }
    }
}
</code></pre>
<h4 id="no3">NO.3</h4>
<pre><code>fn break2() {
    loop {
        if break { print!(&quot;2&quot;) } {
        }
    }
}
</code></pre>
<p>和return 不一样，break不优先处理后面的表达式，上面的函数格式化如下。break在 {println!(&quot;2&quot;)} 之前就退出了。</p>
<pre><code>fn break2() {
    loop {
        if break
        { print!(&quot;2&quot;) }
        {}
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列15]]></title>
        <id>https://jgl666.github.io/post/xxx/</id>
        <link href="https://jgl666.github.io/post/xxx/">
        </link>
        <updated>2020-07-01T08:04:28.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/15">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>trait Trait {
    fn f(&amp;self);
}

impl Trait for u32 {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

impl&lt;'a&gt; Trait for &amp;'a i32 {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let x = &amp;0;
    x.f();
}
</code></pre>
<h2 id="解析">解析</h2>
<p>原理详见<a href="https://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules/28552082#28552082">stackoverflow</a><br></p>
<p>给出了方法解引用步骤</p>
<blockquote>
<p>The core of the algorithm is:</p>
<p>For each &quot;dereference step&quot; U (that is, set U = T and then U = *T, ...)<br><br>
1、if there's a method bar where the receiver type (the type of self in the method) matches U exactly , use it (a &quot;by value method&quot;)<br><br>
2、otherwise, add one auto-ref (take &amp; or &amp;mut of the receiver), and, if some method's receiver matches &amp;U, use it (an &quot;autorefd method&quot;)</p>
</blockquote>
<p>对于上面这题两个trait 实现，这里u32和&amp;u32是两个类型。</p>
<pre><code>impl Trait for u32 
impl&lt;'a&gt; Trait for &amp;'a i32
</code></pre>
<p>现在应用上面的规则：<br><br>
对于</p>
<pre><code>let x = &amp;0;
</code></pre>
<p>此时U为&amp;x，完全匹配方法f的参数类型&amp;self。适用于第一条规则。</p>
<pre><code>//等同于fn f(&amp;u32)
fn f(&amp;self) {
    print!(&quot;1&quot;);
}
</code></pre>
<p>如果这个时候注释掉</p>
<pre><code>impl Trait for u32 {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}
</code></pre>
<p>此时第一条规则不成立，尝试第二条规则，给类型自动加引用。此时x的类型如下：</p>
<pre><code>x: &amp;&amp;u32
</code></pre>
<p>因为针对&amp;u32有实现的trait</p>
<pre><code>impl&lt;'a&gt; Trait for &amp;'a i32 {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<p>此时self 为&amp; &amp;u32,而x为&amp; &amp;u32, 满足参数类型。所以输出2。</p>
<h2 id="拓展">拓展</h2>
<pre><code>trait Trait {
    fn f(&amp;self);
}

impl&lt;'a&gt; Trait for &amp;'a i32 {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

impl&lt;'a&gt; Trait for &amp;'a &amp;i32 {
    fn f(&amp;self) {
        print!(&quot;3&quot;);
    }
}

fn main() {
    let x = &amp;&amp;0;
    x.f();
}
</code></pre>
<p>上面代码输出2<br></p>
<hr>
<p>当注释掉</p>
<pre><code>impl&lt;'a&gt; Trait for &amp;'a i32 {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<p>输出3<br><br>
原理同上</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列14]]></title>
        <id>https://jgl666.github.io/post/ss/</id>
        <link href="https://jgl666.github.io/post/ss/">
        </link>
        <updated>2020-06-30T05:17:54.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/14">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>trait Trait: Sized {
    fn is_reference(self) -&gt; bool;
}

impl&lt;'a, T&gt; Trait for &amp;'a T {
    fn is_reference(self) -&gt; bool {
        true
    }
}

fn main() {
    match 0.is_reference() {
        true =&gt; print!(&quot;1&quot;),
        false =&gt; print!(&quot;0&quot;),
    }

    match '?'.is_reference() {
        true =&gt; print!(&quot;1&quot;),
        false =&gt; {
            impl Trait for char {
                fn is_reference(self) -&gt; bool {
                    false
                }
            }
            print!(&quot;0&quot;)
        }
    }
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>这里如果0.is_reference没有找到对应的方法的话，编译器会自动加上继续寻找</p>
<pre><code>match 0.is_reference() {
    true =&gt; print!(&quot;1&quot;),
    false =&gt; print!(&quot;0&quot;),
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>impl在整个程序中都是可见的，而不仅仅是在包含impl的块中。</p>
<pre><code>    match '?'.is_reference() {
        true =&gt; print!(&quot;1&quot;),
        false =&gt; {
            impl Trait for char {
                fn is_reference(self) -&gt; bool {
                    false
                }
            }
            print!(&quot;0&quot;)
        }
    }
</code></pre>
<h2 id="rust相关知识">Rust相关知识</h2>
<p><a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html">方法调用表达式</a></p>
<blockquote>
<p>The first step is to build a list of candidate receiver types. Obtain these by repeatedly dereferencing the receiver expression's type, adding each type encountered to the list, then finally attempting an unsized coercion at the end, and adding the result type if that is successful. Then, for each candidate T, add &amp;T and &amp;mut T to the list immediately after T.</p>
<p>For instance, if the receiver has type Box&lt;[i32;2]&gt;, then the candidate types will be Box&lt;[i32;2]&gt;, &amp;Box&lt;[i32;2]&gt;, &amp;mut Box&lt;[i32;2]&gt;, [i32; 2] (by dereferencing), &amp;[i32; 2], &amp;mut [i32; 2], [i32] (by unsized coercion), &amp;[i32], and finally &amp;mut [i32].</p>
</blockquote>
<p>Rust在调用方法的时候，<mark>通过重复解除对接收方表达式的类型的引用，将遇到的每种类型添加到列表中来获取这些值。</mark> 然后，对于每个候选T，添加&amp;T和&amp;mut到紧接在T之后的列表中。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列13]]></title>
        <id>https://jgl666.github.io/post/rustquiz13/</id>
        <link href="https://jgl666.github.io/post/rustquiz13/">
        </link>
        <updated>2020-06-29T15:31:18.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/13">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>struct S;

fn main() {
    let [x, y] = &amp;mut [S, S];
    let eq = x as *mut S == y as *mut S;
    print!(&quot;{}&quot;, eq as u8);
}
</code></pre>
<h2 id="解析">解析</h2>
<p>NO.1</p>
<hr>
<p>S是零大小类型，编译器会进行优化。这里数组的地址和两个元素的地址一样。数组[S; 2]大小也是0。</p>
<pre><code>let [x, y] = &amp;mut [S, S];
</code></pre>
<h2 id="rust相关知识">Rust相关知识</h2>
<p><a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">ZSTS</a>类型：<br><br>
Rust认为，任何生产或存储ZST的操作都可以被简化为无操作。存储它甚至没有意义——它不占任何空间。可以在编译时期优化代码，较少不必要的内存分配。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列12]]></title>
        <id>https://jgl666.github.io/post/11/</id>
        <link href="https://jgl666.github.io/post/11/">
        </link>
        <updated>2020-06-29T15:01:04.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/12">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>struct D(u8);

impl Drop for D {
    fn drop(&amp;mut self) {
        print!(&quot;{}&quot;, self.0);
    }
}

struct S {
    d: D,
    x: u8,
}

fn main() {
    let S { x, .. } = S {
        d: D(1),
        x: 2,
    };
    print!(&quot;{}&quot;, x);

    let S { ref x, .. } = S {
        d: D(3),
        x: 4,
    };
    print!(&quot;{}&quot;, x);
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>生成了临时变量S_temp, 然后采用模式匹配，这里x是值拷贝。<br>
S会立马析构，输出12</p>
<pre><code>    let S { x, .. } = S {
        d: D(1),
        x: 2,
    };
    print!(&quot;{}&quot;, x);
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>这里x是对临时变量内部字段的引用，临时变量还不能释放，不然会造成悬垂指针。</p>
<pre><code>let S { ref x, .. } = S {
    d: D(3),
    x: 4,
};
print!(&quot;{}&quot;, x);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列11]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-12/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-12/">
        </link>
        <updated>2020-06-29T09:13:26.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/11">原文链接</a><br>
<br><br><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">Rust Quiz 解读汇总</a></p>
<pre><code>fn f&lt;'a&gt;() {}
fn g&lt;'a: 'a&gt;() {}

fn main() {
    let pf = f::&lt;'static&gt; as fn();
    let pg = g::&lt;'static&gt; as fn();
    print!(&quot;{}&quot;, pf == pg);
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>失败：类型参数没有实例化</p>
<pre><code>fn m&lt;T&gt;() {}

fn main() {
    let m1 = m::&lt;u8&gt;; // ok
    let m2 = m; // error: cannot infer type for `T`
}
</code></pre>
<br>
<p>原文解释<br></p>
<blockquote>
<p>Since the actual choice of lifetime 'a depends on how it is called, we are allowed to omit the lifetime parameter and it will be determined at the call site. The lifetime can even be different for each time it gets called.</p>
</blockquote>
<pre><code>fn m&lt;'a&gt;(_: &amp;'a ()) {}

fn main() {
    let m1 = m; // ok even though 'a isn't provided
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p><strong>原文</strong></p>
<blockquote>
<p>Lifetimes on data types are always early bound except when the developer has explicitly used the HRTB for syntax. On functions, lifetimes are late bound by default but can be early bound if:</p>
<p>The lifetime is declared outside the function signature, e.g. in an associated method of a struct it could be from the struct itself; or</p>
<p>The lifetime parameter is bounded below by some other lifetime that it must outlive. As we've seen, this constraint is not expressible in the HRTB that would be involved in late binding the lifetime.</p>
<p>By these rules, the signature fn f&lt;'a&gt;() has a late bound lifetime parameter while the signature fn g&lt;'a: 'a&gt;() has an early bound lifetime parameter — even though the constraint here is ineffectual.</p>
</blockquote>
<br>
<p><strong>规则如下</strong>：</p>
<ul>
<li>数据类型上的生命周期绑定都是早绑定，除非显示使用HRTB的for语法</li>
<li>函数上生命周期绑定默认为迟绑定，除非函数签名外声明的生命周期，或者绑定到其它生命周期必须更长。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列10]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-11/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-11/">
        </link>
        <updated>2020-06-29T08:25:15.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/10">原文链接</a></p>
<pre><code>trait Trait {
    fn f(&amp;self);
}

impl&lt;'a&gt; dyn Trait + 'a {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for bool {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    Trait::f(&amp;true);
    Trait::f(&amp;true as &amp;dyn Trait);
    &lt;_ as Trait&gt;::f(&amp;true);
    &lt;_ as Trait&gt;::f(&amp;true as &amp;dyn Trait);
    &lt;bool as Trait&gt;::f(&amp;true);
}
</code></pre>
<br>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>调用Trait这个trait 为bool类型实现的f方法</p>
<pre><code>Trait::f(&amp;true);
</code></pre>
<br>
示例如下
<pre><code>trait Trait1{
    fn do_something(&amp;self);
}

trait Trait2{
    fn do_something(&amp;self);
}

struct S;
impl Trait1 for S{
    fn do_something(&amp;self){
        println!(&quot;Trait1&quot;);
    }
}

impl Trait2 for S{
    fn do_something(&amp;self){
        println!(&quot;Trait2&quot;);
    }
}


fn main() {
    //Trait1
    Trait1::do_something(&amp;S);
    //Trait2
    Trait2::do_something(&amp;S);
}
</code></pre>
<br>
<h4 id="no2">NO.2</h4>
<hr>
<p>trait 对象内置的方法会被具体类型实现的方法遮蔽</p>
<pre><code>Trait::f(&amp;true as &amp;dyn Trait);
</code></pre>
<br>
<h4 id="no3">NO.3</h4>
<hr>
<p><a href="https://jgl666.github.io/post/xiao-chu-qi-yi-de-wan-quan-xian-ding-yu-fa/">消除歧义的完全限定语法</a>用来调用trait内部的关联函数或者调用指定trait实现的方法。</p>
<pre><code>&lt;_ as Trait&gt;::f(&amp;true);
//内部方法被遮蔽
&lt;_ as Trait&gt;::f(&amp;true as &amp;dyn Trait);
</code></pre>
<p>示例如下：</p>
<pre><code>trait Trait1{
    fn do_something(){
        println!(&quot;trait 1 do something&quot;)
    }
}


struct S;
impl Trait1 for S{}
impl S{
    fn do_something(){
        println!(&quot;S do something&quot;)
    }
}
fn main() {
    S::do_something();
    &lt;S as Trait1&gt;::do_something();
}
</code></pre>
<br>
<h4 id="no4">NO.4</h4>
<hr>
<p>同上</p>
<pre><code>&lt;bool as Trait&gt;::f(&amp;true);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[消除歧义的完全限定语法]]></title>
        <id>https://jgl666.github.io/post/xiao-chu-qi-yi-de-wan-quan-xian-ding-yu-fa/</id>
        <link href="https://jgl666.github.io/post/xiao-chu-qi-yi-de-wan-quan-xian-ding-yu-fa/">
        </link>
        <updated>2020-06-29T05:43:56.000Z</updated>
        <content type="html"><![CDATA[<h4 id="消除歧义的完全限定语法">消除歧义的完全限定语法</h4>
<hr>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">链接</a><br><br><br>
<strong>起因：</strong> 为同一种类型，实现不同的trait，这些trait中有同名的方法。同名的函数在调用的时候会产生歧义。</p>
<p>如下</p>
<pre><code>trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
</code></pre>
<p>上面的代码有三个重名的函数，类型自身的方法，以及 Pilot 和 Wizard 实现的方法。</p>
<p>当使用Human类型的实例调用 fly 方法的时候，默认调用自身的方法。</p>
<pre><code>fn main() {
    let person = Human;
    person.fly();
}
</code></pre>
<p>为了调用 Pilot trait 或者 wizard trait，需要显示的语法指定。</p>
<pre><code>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre>
<p>关联函数没有self参数，如下。</p>
<pre><code>trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}
</code></pre>
<br>
<p>Animal::baby_name是一个关联函数，而不是一个方法。它没有self参数，Rust不知道具体类型。<br>
<br>为了消除歧义，采用如下调用</p>
<pre><code>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre>
<p>我们为Rust提供了尖括号内的类型注释，完全限定语法格式如下</p>
<pre><code>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<p>可以在调用函数或方法的任何地方使用完全限定语法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列5]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-10/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-10/">
        </link>
        <updated>2020-06-28T13:58:28.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/5">原文链接</a></p>
<pre><code>trait Trait {
    fn p(self);
}

impl&lt;T&gt; Trait for fn(T) {
    fn p(self) {
        print!(&quot;1&quot;);
    }
}

impl&lt;T&gt; Trait for fn(&amp;T) {
    fn p(self) {
        print!(&quot;2&quot;);
    }
}

fn f(_: u8) {}
fn g(_: &amp;u8) {}

fn main() {
    let a: fn(_) = f;
    let b: fn(_) = g;
    let c: fn(&amp;_) = g;
    a.p();
    b.p();
    c.p();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>这里的T是泛型参数，编译的时候会转成具体的类型</p>
<pre><code>impl&lt;T&gt; Trait for fn(T) {
    fn p(self) {
        print!(&quot;1&quot;);
    }
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>这里涉及到对T的引用，实际是有生命周期参数</p>
<pre><code>impl&lt;T&gt; Trait for fn(&amp;T) {
    fn p(self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<p>相当于</p>
<pre><code>impl&lt;T&gt; Trait for for&lt;'a&gt; fn(&amp;'a T) {
    fn p(self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<p>表示T对应具体类型的时候，生命周期要比'a更长。</p>
<h4 id="no3">NO.3</h4>
<hr>
<pre><code>let a: fn(_) = f;
</code></pre>
<p>相当于</p>
<pre><code>let a: fn(u8) = f;
</code></pre>
<h4 id="no4">NO.4</h4>
<hr>
<pre><code>let b: fn(_) = g;
</code></pre>
<p>相当于</p>
<pre><code>let b: fn(&amp;'x u8) = g;
</code></pre>
<h4 id="no5">NO.5</h4>
<hr>
<pre><code>let c: fn(&amp;_) = g;
</code></pre>
<p>相当于</p>
<pre><code>let c: for&lt;'a&gt; fn(&amp;'a u8) = g;
</code></pre>
<br>
<h2 id="rust中相关知识">Rust中相关知识</h2>
<h3 id="hrtb">HRTB</h3>
<hr>
<p><a href="https://stackoverflow.com/questions/35592750/how-does-for-syntax-differ-from-a-regular-lifetime-bound">参考</a><br><br><br>
<a href="https://doc.rust-lang.org/nightly/nomicon/hrtb.html#higher-rank-trait-bounds-hrtbs">HRTBs</a>是Rust中一种特殊的语法。主要用在闭包上面，用来控制闭包的生命周期。<br><br>
<br></p>
<p>下面这段代码编译会失败，</p>
<pre><code>fn show&lt;'a, F&gt;(f:F) where F:Fn(&amp;'a i32)-&gt;&amp;i32{
    let v = 1;
    f(&amp;v);
}
</code></pre>
<p>img<br>
如上图所示，局部变量v的生命周期比'a要短，此时借用方的生命周期长度大于出借方，编译器报错。其实这个时候闭包还没执行，无法判断具体的生命周期参数规则（包括参数、返回值等等）。<mark>所以需要在调用的时候再判断生命周期参数</mark>。<br><br>
<br><br>
这个时候HRTBS就登场了</p>
<pre><code>fn show&lt;F&gt;(f:F) where F:for&lt;'a&gt; Fn(&amp;'a i32)-&gt;&amp;i32{
    let v = 1;
    f(&amp;v);
}
</code></pre>
<p>它告诉编译器，<mark>等在闭包调用的地方才检查生命周期规则，而不是定义的时候。因为闭包不一定引用参数作为返回值，需要根据具体调用者上下文判断。</mark></p>
<pre><code>fn filter&lt;F&gt;(self, f: F) -&gt; Option&lt;T&gt; where F: for&lt;'a&gt; FnOnce(&amp;'a T) -&gt; bool
</code></pre>
<br>
<h3 id="题目分析">题目分析</h3>
<hr>
<p>题目中</p>
<pre><code>fn g(_: &amp;u8) {}
</code></pre>
<p>应用了生命周期省略规则，实际展开应该是</p>
<pre><code>fn g&lt;'x&gt;(_: &amp;'x u8) {}
</code></pre>
<p>解析：</p>
<pre><code>let b: fn(_) = g;
    =&gt;let b:fn(_) = fn&lt;'a&gt;(_:&amp;'x u8)
        =&gt; _ = &amp;'x u8
</code></pre>
<br>
<p>题目中</p>
<pre><code>let c: fn(&amp;_) = g;
//_ 替换为u8 , &amp;后面的生命周期未知，为延迟绑定。匹配for&lt;'a&gt; fn(&amp;'a x)
</code></pre>
]]></content>
    </entry>
</feed>