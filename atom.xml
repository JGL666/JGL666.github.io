<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgl666.github.io</id>
    <title>JGL</title>
    <updated>2020-07-07T09:12:12.156Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgl666.github.io"/>
    <link rel="self" href="https://jgl666.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgl666.github.io/images/avatar.png</logo>
    <icon>https://jgl666.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JGL</rights>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列23]]></title>
        <id>https://jgl666.github.io/post/ssss/</id>
        <link href="https://jgl666.github.io/post/ssss/">
        </link>
        <updated>2020-07-07T09:11:41.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/23">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<hr>
<pre><code>trait Trait {
    fn f(&amp;self);
    fn g(&amp;self);
}

struct S;

impl S {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }

    fn g(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for S {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }

    fn g(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    S.f();
    S.g();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>如果结构体方法和trait中方法重名，默认调用结构体自身的方法。可以使用消除歧义的语法调用trait中的方法。</p>
<pre><code>&lt;S as Trait&gt;::f(&amp;S);
</code></pre>
<p>NO.2</p>
<hr>
<p>S找不到方法，会添加引用，找到Trait中定义的方法</p>
<pre><code>fn g(&amp;self) {
    print!(&quot;2&quot;);
}
</code></pre>
<h4 id="no3">NO.3</h4>
<hr>
<p>如果还是找不到就加上&amp;mut<br>
这里注释掉，输出11</p>
<pre><code>impl Trait for S {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }

    fn g(&amp;self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<h4 id="no4">NO.4</h4>
<hr>
<p>增加新的Trait1，输出33，因为直接匹配到方法中接受类型就是S</p>
<pre><code>trait Trait1{
    fn f(self);
    fn g(self);
}

impl Trait1 for S {
    fn f(self) {
        print!(&quot;3&quot;);
    }

    fn g(self) {
        print!(&quot;3&quot;);
    }
}
</code></pre>
<h4 id="no5">NO.5</h4>
<hr>
<p>这样也可以，输出1，3</p>
<pre><code>trait Trait {
    fn f(&amp;self);
    fn g(&amp;self);
}

struct S;

impl S {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }

    fn g(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

// impl Trait for S {
//     fn f(&amp;self) {
//         print!(&quot;2&quot;);
//     }
//
//     fn g(&amp;self) {
//         print!(&quot;2&quot;);
//     }
// }

trait Trait1{
    fn f(self);
    fn g(self);
}

impl Trait1 for &amp;S {
    fn f(self) {
        print!(&quot;3&quot;);
    }

    fn g(self) {
        print!(&quot;3&quot;);
    }
}
fn main() {
    S.f();
    S.g();
}
</code></pre>
<h4 id="no5-2">NO.5</h4>
<hr>
<p>这里输出33，没找到先解引用</p>
<pre><code>trait Trait {
    fn f(&amp;self);
    fn g(&amp;self);
}

struct S;

// impl S {
//     fn f(&amp;self) {
//         print!(&quot;1&quot;);
//     }
//
//     fn g(&amp;mut self) {
//         print!(&quot;1&quot;);
//     }
// }

impl Trait for S {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }

    fn g(&amp;self) {
        print!(&quot;2&quot;);
    }
}

trait Trait1{
    fn f(self);
    fn g(self);
}

impl Trait1 for S {
    fn f(self) {
        print!(&quot;3&quot;);
    }

    fn g(self) {
        print!(&quot;3&quot;);
    }
}
fn main() {
    &amp;S.f();
    &amp;S.g();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列31]]></title>
        <id>https://jgl666.github.io/post/xxafaba/</id>
        <link href="https://jgl666.github.io/post/xxafaba/">
        </link>
        <updated>2020-07-04T07:21:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="原文链接"><a href="https://dtolnay.github.io/rust-quiz/31">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a><br><br>
<a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html#method-call-expressions">相关文档</a></h2>
<pre><code>trait Or {
    fn f(self);
}

struct T;

impl Or for &amp;T {
    fn f(self) {
        print!(&quot;1&quot;);
    }
}

impl Or for &amp;&amp;&amp;&amp;T {
    fn f(self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let t = T;
    let wt = &amp;T;
    let wwt = &amp;&amp;T;
    let wwwt = &amp;&amp;&amp;T;
    let wwwwt = &amp;&amp;&amp;&amp;T;
    let wwwwwt = &amp;&amp;&amp;&amp;&amp;T;
    t.f();
    wt.f();
    wwt.f();
    wwwt.f();
    wwwwt.f();
    wwwwwt.f();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>尝试寻找T对应的f方法，没有找到，然后给T加上&amp;，找到对应的方法</p>
<pre><code>let t = T;
t.f();
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>直接找到对应的类型&amp;T</p>
<pre><code>let wt = &amp;T;
wt.f();
</code></pre>
<h4 id="no3">NO.3</h4>
<hr>
<p>找到对应的类型&amp;&amp;T,没找到,加上&amp;,还是没有，然后解引用，找到&amp;T</p>
<pre><code>let wwt = &amp;&amp;T;
wwt.f();
</code></pre>
<h4 id="no4">NO.4</h4>
<hr>
<p>找到对应的类型&amp;&amp;&amp;T,没找到,加上&amp;,找到 &amp;&amp;&amp;&amp;T</p>
<pre><code>let wwwt = &amp;&amp;&amp;T;
wwwt.f();
</code></pre>
<h4 id="no5">NO.5</h4>
<hr>
<p>找到对应的类型&amp;&amp;&amp;T,没找到,加上&amp;,没找到,解引用找到</p>
<pre><code>let wwwwt = &amp;&amp;&amp;&amp;T;
wwwwt.f();
</code></pre>
<h4 id="no6">NO.6</h4>
<hr>
<p>找到对应的类型&amp;&amp;&amp;&amp;&amp;T,没找到,加上&amp;, 没找到,解引用找到</p>
<pre><code>let wwwwwt = &amp;&amp;&amp;&amp;&amp;T;
wwwwwt.f();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列32]]></title>
        <id>https://jgl666.github.io/post/xx/</id>
        <link href="https://jgl666.github.io/post/xx/">
        </link>
        <updated>2020-07-02T14:58:41.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/32">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<hr>
<pre><code>fn check(x: i32) -&gt; bool {
    print!(&quot;{}&quot;, x);
    false
}

fn main() {
    match (1, 2) {
        (x, _) | (_, x) if check(x) =&gt; {
            print!(&quot;3&quot;)
        }
        _ =&gt; print!(&quot;4&quot;),
    }
}
</code></pre>
<h2 id="解析">解析</h2>
<p>参看<a href="https://doc.rust-lang.org/reference/expressions/match-expr.html#match-guards">match guard</a><br><br>
上面这题的匹配过程：<br>
Rust match 匹配到 <mark>(x , _)</mark> ，此时x = 1, 然后执行 if 判断，check(x) 输出 1 , 返回false , Rust 继续匹配，匹配到 <mark>( _ , x)</mark>， 此时x = 2，再次执行 if 判断语句，返回false。继续匹配下面一条，因为 _ 是通配符，所以输出4<br><br>
流程如下图：<br>
<img src="https://jgl666.github.io/post-images/1593701933236.PNG" alt="" loading="lazy"><br>
<br></p>
<h2 id="拓展">拓展</h2>
<p>改为true 输出1 3</p>
<pre><code>fn check(x: i32) -&gt; bool {
    print!(&quot;{}&quot;, x);
    true
}

fn main() {
    match (1, 2) {
        (x, _) | (_, x) if check(x) =&gt; {
            print!(&quot;3&quot;)
        }
        _ =&gt; print!(&quot;4&quot;),
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列20]]></title>
        <id>https://jgl666.github.io/post/s/</id>
        <link href="https://jgl666.github.io/post/s/">
        </link>
        <updated>2020-07-02T05:04:42.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/15">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>fn return1() {
    if (return { print!(&quot;1&quot;) }) {
    }
}

fn return2() {
    if return { print!(&quot;2&quot;) } {
    }
}

fn break1() {
    loop {
        if (break { print!(&quot;1&quot;) }) {
        }
    }
}

fn break2() {
    loop {
        if break { print!(&quot;2&quot;) } {
        }
    }
}

fn main() {
    return1();
    return2();
    break1();
    break2();
}
</code></pre>
<h2 id="解析">解析</h2>
<p>参照<a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">表达式优先级</a><br></p>
<h4 id="no1">NO.1</h4>
<hr>
<p>return 总是优化处理后面的表达式</p>
<pre><code>fn return1() {
    if (return { print!(&quot;1&quot;) }) {
    }
}

fn return2() {
    if return { print!(&quot;2&quot;) } {
    }
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>() 优先级大于break，先计算括号表达式，输出1</p>
<pre><code>fn break1() {
    loop {
        if (break { print!(&quot;1&quot;) }) {
        }
    }
}
</code></pre>
<h4 id="no3">NO.3</h4>
<pre><code>fn break2() {
    loop {
        if break { print!(&quot;2&quot;) } {
        }
    }
}
</code></pre>
<p>和return 不一样，break不优先处理后面的表达式，上面的函数格式化如下。break在 {println!(&quot;2&quot;)} 之前就退出了。</p>
<pre><code>fn break2() {
    loop {
        if break
        { print!(&quot;2&quot;) }
        {}
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列15]]></title>
        <id>https://jgl666.github.io/post/xxx/</id>
        <link href="https://jgl666.github.io/post/xxx/">
        </link>
        <updated>2020-07-01T08:04:28.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/15">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>trait Trait {
    fn f(&amp;self);
}

impl Trait for u32 {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

impl&lt;'a&gt; Trait for &amp;'a i32 {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let x = &amp;0;
    x.f();
}
</code></pre>
<h2 id="解析">解析</h2>
<p>原理详见<a href="https://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules/28552082#28552082">stackoverflow</a><br></p>
<p>给出了方法解引用步骤</p>
<blockquote>
<p>The core of the algorithm is:</p>
<p>For each &quot;dereference step&quot; U (that is, set U = T and then U = *T, ...)<br><br>
1、if there's a method bar where the receiver type (the type of self in the method) matches U exactly , use it (a &quot;by value method&quot;)<br><br>
2、otherwise, add one auto-ref (take &amp; or &amp;mut of the receiver), and, if some method's receiver matches &amp;U, use it (an &quot;autorefd method&quot;)</p>
</blockquote>
<p>对于上面这题两个trait 实现，这里u32和&amp;u32是两个类型。</p>
<pre><code>impl Trait for u32 
impl&lt;'a&gt; Trait for &amp;'a i32
</code></pre>
<p>现在应用上面的规则：<br><br>
对于</p>
<pre><code>let x = &amp;0;
</code></pre>
<p>此时U为&amp;x，完全匹配方法f的参数类型&amp;self。适用于第一条规则。</p>
<pre><code>//等同于fn f(&amp;u32)
fn f(&amp;self) {
    print!(&quot;1&quot;);
}
</code></pre>
<p>如果这个时候注释掉</p>
<pre><code>impl Trait for u32 {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}
</code></pre>
<p>此时第一条规则不成立，尝试第二条规则，给类型自动加引用。此时x的类型如下：</p>
<pre><code>x: &amp;&amp;u32
</code></pre>
<p>因为针对&amp;u32有实现的trait</p>
<pre><code>impl&lt;'a&gt; Trait for &amp;'a i32 {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<p>此时self 为&amp; &amp;u32,而x为&amp; &amp;u32, 满足参数类型。所以输出2。</p>
<h2 id="拓展">拓展</h2>
<pre><code>trait Trait {
    fn f(&amp;self);
}

impl&lt;'a&gt; Trait for &amp;'a i32 {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

impl&lt;'a&gt; Trait for &amp;'a &amp;i32 {
    fn f(&amp;self) {
        print!(&quot;3&quot;);
    }
}

fn main() {
    let x = &amp;&amp;0;
    x.f();
}
</code></pre>
<p>上面代码输出2<br></p>
<hr>
<p>当注释掉</p>
<pre><code>impl&lt;'a&gt; Trait for &amp;'a i32 {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<p>输出3<br><br>
原理同上</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列14]]></title>
        <id>https://jgl666.github.io/post/ss/</id>
        <link href="https://jgl666.github.io/post/ss/">
        </link>
        <updated>2020-06-30T05:17:54.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/14">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>trait Trait: Sized {
    fn is_reference(self) -&gt; bool;
}

impl&lt;'a, T&gt; Trait for &amp;'a T {
    fn is_reference(self) -&gt; bool {
        true
    }
}

fn main() {
    match 0.is_reference() {
        true =&gt; print!(&quot;1&quot;),
        false =&gt; print!(&quot;0&quot;),
    }

    match '?'.is_reference() {
        true =&gt; print!(&quot;1&quot;),
        false =&gt; {
            impl Trait for char {
                fn is_reference(self) -&gt; bool {
                    false
                }
            }
            print!(&quot;0&quot;)
        }
    }
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>这里如果0.is_reference没有找到对应的方法的话，编译器会自动加上继续寻找</p>
<pre><code>match 0.is_reference() {
    true =&gt; print!(&quot;1&quot;),
    false =&gt; print!(&quot;0&quot;),
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>impl在整个程序中都是可见的，而不仅仅是在包含impl的块中。</p>
<pre><code>    match '?'.is_reference() {
        true =&gt; print!(&quot;1&quot;),
        false =&gt; {
            impl Trait for char {
                fn is_reference(self) -&gt; bool {
                    false
                }
            }
            print!(&quot;0&quot;)
        }
    }
</code></pre>
<h2 id="rust相关知识">Rust相关知识</h2>
<p><a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html">方法调用表达式</a></p>
<blockquote>
<p>The first step is to build a list of candidate receiver types. Obtain these by repeatedly dereferencing the receiver expression's type, adding each type encountered to the list, then finally attempting an unsized coercion at the end, and adding the result type if that is successful. Then, for each candidate T, add &amp;T and &amp;mut T to the list immediately after T.</p>
<p>For instance, if the receiver has type Box&lt;[i32;2]&gt;, then the candidate types will be Box&lt;[i32;2]&gt;, &amp;Box&lt;[i32;2]&gt;, &amp;mut Box&lt;[i32;2]&gt;, [i32; 2] (by dereferencing), &amp;[i32; 2], &amp;mut [i32; 2], [i32] (by unsized coercion), &amp;[i32], and finally &amp;mut [i32].</p>
</blockquote>
<p>Rust在调用方法的时候，<mark>通过重复解除对接收方表达式的类型的引用，将遇到的每种类型添加到列表中来获取这些值。</mark> 然后，对于每个候选T，添加&amp;T和&amp;mut到紧接在T之后的列表中。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列13]]></title>
        <id>https://jgl666.github.io/post/rustquiz13/</id>
        <link href="https://jgl666.github.io/post/rustquiz13/">
        </link>
        <updated>2020-06-29T15:31:18.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/13">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>struct S;

fn main() {
    let [x, y] = &amp;mut [S, S];
    let eq = x as *mut S == y as *mut S;
    print!(&quot;{}&quot;, eq as u8);
}
</code></pre>
<h2 id="解析">解析</h2>
<p>NO.1</p>
<hr>
<p>S是零大小类型，编译器会进行优化。这里数组的地址和两个元素的地址一样。数组[S; 2]大小也是0。</p>
<pre><code>let [x, y] = &amp;mut [S, S];
</code></pre>
<h2 id="rust相关知识">Rust相关知识</h2>
<p><a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">ZSTS</a>类型：<br><br>
Rust认为，任何生产或存储ZST的操作都可以被简化为无操作。存储它甚至没有意义——它不占任何空间。可以在编译时期优化代码，较少不必要的内存分配。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列12]]></title>
        <id>https://jgl666.github.io/post/11/</id>
        <link href="https://jgl666.github.io/post/11/">
        </link>
        <updated>2020-06-29T15:01:04.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/12">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>struct D(u8);

impl Drop for D {
    fn drop(&amp;mut self) {
        print!(&quot;{}&quot;, self.0);
    }
}

struct S {
    d: D,
    x: u8,
}

fn main() {
    let S { x, .. } = S {
        d: D(1),
        x: 2,
    };
    print!(&quot;{}&quot;, x);

    let S { ref x, .. } = S {
        d: D(3),
        x: 4,
    };
    print!(&quot;{}&quot;, x);
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>生成了临时变量S_temp, 然后采用模式匹配，这里x是值拷贝。<br>
S会立马析构，输出12</p>
<pre><code>    let S { x, .. } = S {
        d: D(1),
        x: 2,
    };
    print!(&quot;{}&quot;, x);
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>这里x是对临时变量内部字段的引用，临时变量还不能释放，不然会造成悬垂指针。</p>
<pre><code>let S { ref x, .. } = S {
    d: D(3),
    x: 4,
};
print!(&quot;{}&quot;, x);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列11]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-12/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-12/">
        </link>
        <updated>2020-06-29T09:13:26.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/11">原文链接</a><br>
<br><br><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">Rust Quiz 解读汇总</a></p>
<pre><code>fn f&lt;'a&gt;() {}
fn g&lt;'a: 'a&gt;() {}

fn main() {
    let pf = f::&lt;'static&gt; as fn();
    let pg = g::&lt;'static&gt; as fn();
    print!(&quot;{}&quot;, pf == pg);
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>失败：类型参数没有实例化</p>
<pre><code>fn m&lt;T&gt;() {}

fn main() {
    let m1 = m::&lt;u8&gt;; // ok
    let m2 = m; // error: cannot infer type for `T`
}
</code></pre>
<br>
<p>原文解释<br></p>
<blockquote>
<p>Since the actual choice of lifetime 'a depends on how it is called, we are allowed to omit the lifetime parameter and it will be determined at the call site. The lifetime can even be different for each time it gets called.</p>
</blockquote>
<pre><code>fn m&lt;'a&gt;(_: &amp;'a ()) {}

fn main() {
    let m1 = m; // ok even though 'a isn't provided
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p><strong>原文</strong></p>
<blockquote>
<p>Lifetimes on data types are always early bound except when the developer has explicitly used the HRTB for syntax. On functions, lifetimes are late bound by default but can be early bound if:</p>
<p>The lifetime is declared outside the function signature, e.g. in an associated method of a struct it could be from the struct itself; or</p>
<p>The lifetime parameter is bounded below by some other lifetime that it must outlive. As we've seen, this constraint is not expressible in the HRTB that would be involved in late binding the lifetime.</p>
<p>By these rules, the signature fn f&lt;'a&gt;() has a late bound lifetime parameter while the signature fn g&lt;'a: 'a&gt;() has an early bound lifetime parameter — even though the constraint here is ineffectual.</p>
</blockquote>
<br>
<p><strong>规则如下</strong>：</p>
<ul>
<li>数据类型上的生命周期绑定都是早绑定，除非显示使用HRTB的for语法</li>
<li>函数上生命周期绑定默认为迟绑定，除非函数签名外声明的生命周期，或者绑定到其它生命周期必须更长。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列10]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-11/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-11/">
        </link>
        <updated>2020-06-29T08:25:15.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/10">原文链接</a></p>
<pre><code>trait Trait {
    fn f(&amp;self);
}

impl&lt;'a&gt; dyn Trait + 'a {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for bool {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    Trait::f(&amp;true);
    Trait::f(&amp;true as &amp;dyn Trait);
    &lt;_ as Trait&gt;::f(&amp;true);
    &lt;_ as Trait&gt;::f(&amp;true as &amp;dyn Trait);
    &lt;bool as Trait&gt;::f(&amp;true);
}
</code></pre>
<br>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>调用Trait这个trait 为bool类型实现的f方法</p>
<pre><code>Trait::f(&amp;true);
</code></pre>
<br>
示例如下
<pre><code>trait Trait1{
    fn do_something(&amp;self);
}

trait Trait2{
    fn do_something(&amp;self);
}

struct S;
impl Trait1 for S{
    fn do_something(&amp;self){
        println!(&quot;Trait1&quot;);
    }
}

impl Trait2 for S{
    fn do_something(&amp;self){
        println!(&quot;Trait2&quot;);
    }
}


fn main() {
    //Trait1
    Trait1::do_something(&amp;S);
    //Trait2
    Trait2::do_something(&amp;S);
}
</code></pre>
<br>
<h4 id="no2">NO.2</h4>
<hr>
<p>trait 对象内置的方法会被具体类型实现的方法遮蔽</p>
<pre><code>Trait::f(&amp;true as &amp;dyn Trait);
</code></pre>
<br>
<h4 id="no3">NO.3</h4>
<hr>
<p><a href="https://jgl666.github.io/post/xiao-chu-qi-yi-de-wan-quan-xian-ding-yu-fa/">消除歧义的完全限定语法</a>用来调用trait内部的关联函数或者调用指定trait实现的方法。</p>
<pre><code>&lt;_ as Trait&gt;::f(&amp;true);
//内部方法被遮蔽
&lt;_ as Trait&gt;::f(&amp;true as &amp;dyn Trait);
</code></pre>
<p>示例如下：</p>
<pre><code>trait Trait1{
    fn do_something(){
        println!(&quot;trait 1 do something&quot;)
    }
}


struct S;
impl Trait1 for S{}
impl S{
    fn do_something(){
        println!(&quot;S do something&quot;)
    }
}
fn main() {
    S::do_something();
    &lt;S as Trait1&gt;::do_something();
}
</code></pre>
<br>
<h4 id="no4">NO.4</h4>
<hr>
<p>同上</p>
<pre><code>&lt;bool as Trait&gt;::f(&amp;true);
</code></pre>
]]></content>
    </entry>
</feed>