<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgl666.github.io</id>
    <title>JGL</title>
    <updated>2020-06-29T15:01:45.798Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgl666.github.io"/>
    <link rel="self" href="https://jgl666.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgl666.github.io/images/avatar.png</logo>
    <icon>https://jgl666.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JGL</rights>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列12]]></title>
        <id>https://jgl666.github.io/post/11/</id>
        <link href="https://jgl666.github.io/post/11/">
        </link>
        <updated>2020-06-29T15:01:04.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/12">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>struct D(u8);

impl Drop for D {
    fn drop(&amp;mut self) {
        print!(&quot;{}&quot;, self.0);
    }
}

struct S {
    d: D,
    x: u8,
}

fn main() {
    let S { x, .. } = S {
        d: D(1),
        x: 2,
    };
    print!(&quot;{}&quot;, x);

    let S { ref x, .. } = S {
        d: D(3),
        x: 4,
    };
    print!(&quot;{}&quot;, x);
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>生成了临时变量S_temp, 然后采用模式匹配，这里x是值拷贝。<br>
S会立马析构，输出12</p>
<pre><code>    let S { x, .. } = S {
        d: D(1),
        x: 2,
    };
    print!(&quot;{}&quot;, x);
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>这里x是对临时变量内部字段的引用，临时变量还不能释放，不然会造成悬垂指针。</p>
<pre><code>let S { ref x, .. } = S {
    d: D(3),
    x: 4,
};
print!(&quot;{}&quot;, x);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列11]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-12/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-12/">
        </link>
        <updated>2020-06-29T09:13:26.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/11">原文链接</a><br>
<br><br><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">Rust Quiz 解读汇总</a></p>
<pre><code>fn f&lt;'a&gt;() {}
fn g&lt;'a: 'a&gt;() {}

fn main() {
    let pf = f::&lt;'static&gt; as fn();
    let pg = g::&lt;'static&gt; as fn();
    print!(&quot;{}&quot;, pf == pg);
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>失败：类型参数没有实例化</p>
<pre><code>fn m&lt;T&gt;() {}

fn main() {
    let m1 = m::&lt;u8&gt;; // ok
    let m2 = m; // error: cannot infer type for `T`
}
</code></pre>
<br>
<p>原文解释<br></p>
<blockquote>
<p>Since the actual choice of lifetime 'a depends on how it is called, we are allowed to omit the lifetime parameter and it will be determined at the call site. The lifetime can even be different for each time it gets called.</p>
</blockquote>
<pre><code>fn m&lt;'a&gt;(_: &amp;'a ()) {}

fn main() {
    let m1 = m; // ok even though 'a isn't provided
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p><strong>原文</strong></p>
<blockquote>
<p>Lifetimes on data types are always early bound except when the developer has explicitly used the HRTB for syntax. On functions, lifetimes are late bound by default but can be early bound if:</p>
<p>The lifetime is declared outside the function signature, e.g. in an associated method of a struct it could be from the struct itself; or</p>
<p>The lifetime parameter is bounded below by some other lifetime that it must outlive. As we've seen, this constraint is not expressible in the HRTB that would be involved in late binding the lifetime.</p>
<p>By these rules, the signature fn f&lt;'a&gt;() has a late bound lifetime parameter while the signature fn g&lt;'a: 'a&gt;() has an early bound lifetime parameter — even though the constraint here is ineffectual.</p>
</blockquote>
<br>
<p><strong>规则如下</strong>：</p>
<ul>
<li>数据类型上的生命周期绑定都是早绑定，除非显示使用HRTB的for语法</li>
<li>函数上生命周期绑定默认为迟绑定，除非函数签名外声明的生命周期，或者绑定到其它生命周期必须更长。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列10]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-11/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-11/">
        </link>
        <updated>2020-06-29T08:25:15.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/10">原文链接</a></p>
<pre><code>trait Trait {
    fn f(&amp;self);
}

impl&lt;'a&gt; dyn Trait + 'a {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for bool {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    Trait::f(&amp;true);
    Trait::f(&amp;true as &amp;dyn Trait);
    &lt;_ as Trait&gt;::f(&amp;true);
    &lt;_ as Trait&gt;::f(&amp;true as &amp;dyn Trait);
    &lt;bool as Trait&gt;::f(&amp;true);
}
</code></pre>
<br>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>调用Trait这个trait 为bool类型实现的f方法</p>
<pre><code>Trait::f(&amp;true);
</code></pre>
<br>
示例如下
<pre><code>trait Trait1{
    fn do_something(&amp;self);
}

trait Trait2{
    fn do_something(&amp;self);
}

struct S;
impl Trait1 for S{
    fn do_something(&amp;self){
        println!(&quot;Trait1&quot;);
    }
}

impl Trait2 for S{
    fn do_something(&amp;self){
        println!(&quot;Trait2&quot;);
    }
}


fn main() {
    //Trait1
    Trait1::do_something(&amp;S);
    //Trait2
    Trait2::do_something(&amp;S);
}
</code></pre>
<br>
<h4 id="no2">NO.2</h4>
<hr>
<p>trait 对象内置的方法会被具体类型实现的方法遮蔽</p>
<pre><code>Trait::f(&amp;true as &amp;dyn Trait);
</code></pre>
<br>
<h4 id="no3">NO.3</h4>
<hr>
<p><a href="https://jgl666.github.io/post/xiao-chu-qi-yi-de-wan-quan-xian-ding-yu-fa/">消除歧义的完全限定语法</a>用来调用trait内部的关联函数或者调用指定trait实现的方法。</p>
<pre><code>&lt;_ as Trait&gt;::f(&amp;true);
//内部方法被遮蔽
&lt;_ as Trait&gt;::f(&amp;true as &amp;dyn Trait);
</code></pre>
<p>示例如下：</p>
<pre><code>trait Trait1{
    fn do_something(){
        println!(&quot;trait 1 do something&quot;)
    }
}


struct S;
impl Trait1 for S{}
impl S{
    fn do_something(){
        println!(&quot;S do something&quot;)
    }
}
fn main() {
    S::do_something();
    &lt;S as Trait1&gt;::do_something();
}
</code></pre>
<br>
<h4 id="no4">NO.4</h4>
<hr>
<p>同上</p>
<pre><code>&lt;bool as Trait&gt;::f(&amp;true);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[消除歧义的完全限定语法]]></title>
        <id>https://jgl666.github.io/post/xiao-chu-qi-yi-de-wan-quan-xian-ding-yu-fa/</id>
        <link href="https://jgl666.github.io/post/xiao-chu-qi-yi-de-wan-quan-xian-ding-yu-fa/">
        </link>
        <updated>2020-06-29T05:43:56.000Z</updated>
        <content type="html"><![CDATA[<h4 id="消除歧义的完全限定语法">消除歧义的完全限定语法</h4>
<hr>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">链接</a><br><br><br>
<strong>起因：</strong> 为同一种类型，实现不同的trait，这些trait中有同名的方法。同名的函数在调用的时候会产生歧义。</p>
<p>如下</p>
<pre><code>trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
</code></pre>
<p>上面的代码有三个重名的函数，类型自身的方法，以及 Pilot 和 Wizard 实现的方法。</p>
<p>当使用Human类型的实例调用 fly 方法的时候，默认调用自身的方法。</p>
<pre><code>fn main() {
    let person = Human;
    person.fly();
}
</code></pre>
<p>为了调用 Pilot trait 或者 wizard trait，需要显示的语法指定。</p>
<pre><code>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre>
<p>关联函数没有self参数，如下。</p>
<pre><code>trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}
</code></pre>
<br>
<p>Animal::baby_name是一个关联函数，而不是一个方法。它没有self参数，Rust不知道具体类型。<br>
<br>为了消除歧义，采用如下调用</p>
<pre><code>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre>
<p>我们为Rust提供了尖括号内的类型注释，完全限定语法格式如下</p>
<pre><code>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<p>可以在调用函数或方法的任何地方使用完全限定语法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列5]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-10/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-10/">
        </link>
        <updated>2020-06-28T13:58:28.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/5">原文链接</a></p>
<pre><code>trait Trait {
    fn p(self);
}

impl&lt;T&gt; Trait for fn(T) {
    fn p(self) {
        print!(&quot;1&quot;);
    }
}

impl&lt;T&gt; Trait for fn(&amp;T) {
    fn p(self) {
        print!(&quot;2&quot;);
    }
}

fn f(_: u8) {}
fn g(_: &amp;u8) {}

fn main() {
    let a: fn(_) = f;
    let b: fn(_) = g;
    let c: fn(&amp;_) = g;
    a.p();
    b.p();
    c.p();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>这里的T是泛型参数，编译的时候会转成具体的类型</p>
<pre><code>impl&lt;T&gt; Trait for fn(T) {
    fn p(self) {
        print!(&quot;1&quot;);
    }
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>这里涉及到对T的引用，实际是有生命周期参数</p>
<pre><code>impl&lt;T&gt; Trait for fn(&amp;T) {
    fn p(self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<p>相当于</p>
<pre><code>impl&lt;T&gt; Trait for for&lt;'a&gt; fn(&amp;'a T) {
    fn p(self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<p>表示T对应具体类型的时候，生命周期要比'a更长。</p>
<h4 id="no3">NO.3</h4>
<hr>
<pre><code>let a: fn(_) = f;
</code></pre>
<p>相当于</p>
<pre><code>let a: fn(u8) = f;
</code></pre>
<h4 id="no4">NO.4</h4>
<hr>
<pre><code>let b: fn(_) = g;
</code></pre>
<p>相当于</p>
<pre><code>let b: fn(&amp;'x u8) = g;
</code></pre>
<h4 id="no5">NO.5</h4>
<hr>
<pre><code>let c: fn(&amp;_) = g;
</code></pre>
<p>相当于</p>
<pre><code>let c: for&lt;'a&gt; fn(&amp;'a u8) = g;
</code></pre>
<br>
<h2 id="rust中相关知识">Rust中相关知识</h2>
<h3 id="hrtb">HRTB</h3>
<hr>
<p><a href="https://stackoverflow.com/questions/35592750/how-does-for-syntax-differ-from-a-regular-lifetime-bound">参考</a><br><br><br>
<a href="https://doc.rust-lang.org/nightly/nomicon/hrtb.html#higher-rank-trait-bounds-hrtbs">HRTBs</a>是Rust中一种特殊的语法。主要用在闭包上面，用来控制闭包的生命周期。<br><br>
<br></p>
<p>下面这段代码编译会失败，</p>
<pre><code>fn show&lt;'a, F&gt;(f:F) where F:Fn(&amp;'a i32)-&gt;&amp;i32{
    let v = 1;
    f(&amp;v);
}
</code></pre>
<p>img<br>
如上图所示，局部变量v的生命周期比'a要短，此时借用方的生命周期长度大于出借方，编译器报错。其实这个时候闭包还没执行，无法判断具体的生命周期参数规则（包括参数、返回值等等）。<mark>所以需要在调用的时候再判断生命周期参数</mark>。<br><br>
<br><br>
这个时候HRTBS就登场了</p>
<pre><code>fn show&lt;F&gt;(f:F) where F:for&lt;'a&gt; Fn(&amp;'a i32)-&gt;&amp;i32{
    let v = 1;
    f(&amp;v);
}
</code></pre>
<p>它告诉编译器，<mark>等在闭包调用的地方才检查生命周期规则，而不是定义的时候。因为闭包不一定引用参数作为返回值，需要根据具体调用者上下文判断。</mark></p>
<pre><code>fn filter&lt;F&gt;(self, f: F) -&gt; Option&lt;T&gt; where F: for&lt;'a&gt; FnOnce(&amp;'a T) -&gt; bool
</code></pre>
<br>
<h3 id="题目分析">题目分析</h3>
<hr>
<p>题目中</p>
<pre><code>fn g(_: &amp;u8) {}
</code></pre>
<p>应用了生命周期省略规则，实际展开应该是</p>
<pre><code>fn g&lt;'x&gt;(_: &amp;'x u8) {}
</code></pre>
<p>解析：</p>
<pre><code>let b: fn(_) = g;
    =&gt;let b:fn(_) = fn&lt;'a&gt;(_:&amp;'x u8)
        =&gt; _ = &amp;'x u8
</code></pre>
<br>
<p>题目中</p>
<pre><code>let c: fn(&amp;_) = g;
//_ 替换为u8 , &amp;后面的生命周期未知，为延迟绑定。匹配for&lt;'a&gt; fn(&amp;'a x)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列9]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-9/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-9/">
        </link>
        <updated>2020-06-26T09:08:06.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/9">原文链接</a><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">参考</a></p>
<pre><code>macro_rules! m {
    (1) =&gt; { print!(&quot;1&quot;) };
    ($tt:tt) =&gt; { print!(&quot;2&quot;) };
}

macro_rules! e {
    ($e:expr) =&gt; { m!($e) };
}

macro_rules! t {
    ($tt:tt) =&gt; { e!($tt); m!($tt); };
}

fn main() {
    t!(1);
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>e!(1)扩展为m!(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>)</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi></mrow><annotation encoding="application/x-tex">e)，其中</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span></span></span></span>e是包含1的不透明表达式。它不会匹配字面量，只会匹配tt类型或者expr类型</p>
<pre><code>macro_rules! e {
    ($e:expr) =&gt; { m!($e) };
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<pre><code>macro_rules! m {
    (1) =&gt; { print!(&quot;1&quot;) };
    ($tt:tt) =&gt; { print!(&quot;2&quot;) };
}
</code></pre>
<p>为什么expr 可以匹配到 tt<br><br>
tt 是token类型，可以匹配任何类型，因为token包含一切符号。<br><br>
详见<a href="https://stackoverflow.com/questions/40302026/what-does-the-tt-metavariable-type-mean-in-rust-macros">链接</a></p>
<blockquote>
<p>Token tree is the least demanding metavariable type: it matches anything. It's often used in macros which have a “don't really care” part, and especially in macros which have a “head” and a “tail” part. For example, the println! macros have a branch matching ($fmt:expr, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo></mrow><annotation encoding="application/x-tex">(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span></span></span></span>arg:tt)<em>) where $fmt is the format string, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo></mrow><annotation encoding="application/x-tex">(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span></span></span></span>arg:tt)</em> means “all the rest” and is just forwarded to format_args!. Which means that println! does not need to know the actual format and do complicated matching with it.</p>
</blockquote>
<p>如果变成下面的宏，就会匹配expr</p>
<pre><code>macro_rules! m {
    (1) =&gt; { print!(&quot;1&quot;) };
    ($e:expr) =&gt; { print!(&quot;3&quot;) };
    ($tt:tt) =&gt; { print!(&quot;2&quot;) };
}
</code></pre>
<h2 id="rust相关知识">Rust相关知识</h2>
<p>不透明词条树 : 不能匹配字面量的词条树<br><br>
以下是不透明词条类型</p>
<pre><code>$:block
$:expr
$:item
$:literal
$:meta
$:pat
$:path
$:stmt
$:ty
</code></pre>
<p>透明词条类型</p>
<pre><code>$:ident
$:lifetime
$:tt
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列8]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-8/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-8/">
        </link>
        <updated>2020-06-26T08:49:30.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/8">原文链接</a><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">参考</a></p>
<pre><code>macro_rules! m {
    (==&gt;) =&gt; { print!(&quot;1&quot;); };
    (= = &gt;) =&gt; { print!(&quot;2&quot;); };
    (== &gt;) =&gt; { print!(&quot;3&quot;); };
    (= =&gt;) =&gt; { print!(&quot;4&quot;); };
}

fn main() {
    m!(==&gt;);
    m!(= = &gt;);
    m!(== &gt;);
    m!(= =&gt;);
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<pre><code> (==&gt;) =&gt; { print!(&quot;1&quot;); };
</code></pre>
<p>这个符号Rust中不存在，按照贪心算法，== 被分为一组，&gt;被分为一组</p>
<pre><code>m!(==&gt;);
m!(== &gt;);
</code></pre>
<p>这两个都会分组为（==） 和 (&gt;)</p>
<h4 id="no2">NO.2</h4>
<hr>
<pre><code>m!(= = &gt;);
</code></pre>
<p>没什么好说的，三个组分别是(=)、(=)、(&gt;)</p>
<h4 id="no3">NO3</h4>
<hr>
<pre><code>(= =&gt;) =&gt; { print!(&quot;4&quot;); };
</code></pre>
<p>没什么好说的，三个组分别是=)、(=&gt;)</p>
<h2 id="rust相关知识">Rust相关知识</h2>
<p>标点符号在macro_rules宏中会根据Rust中标点符号分组。</p>
<pre><code>=&lt;&lt;
</code></pre>
<p>Rust的宏将=&lt;&lt;分组，分组依据是Rust中<a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">标点符号</a>，根据贪心算法先取=, 后面的&lt;&lt;，遇到&lt;是一个符号，&lt;&lt;也是一个符号，就将&lt;&lt; 作为一个符号分组</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列7]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-7/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-7/">
        </link>
        <updated>2020-06-26T08:43:06.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/7">原文链接</a><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">参考</a></p>
<pre><code>
#[repr(u8)]
enum Enum {
    First,
    Second,
}

impl Enum {
    fn p(self) {
        match self {
            First =&gt; print!(&quot;1&quot;),
            Second =&gt; print!(&quot;2&quot;),
        }
    }
}

fn main() {
    Enum::p(unsafe {
        std::mem::transmute(1u8)
    });
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>将一种类型的值的位重新解释为另一种类型。这两种类型必须具有相同的大小</p>
<pre><code>std::mem::transmute(1u8)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://jgl666.github.io/post-images/1593161323734.png" alt="" loading="lazy"></figure>
<h4 id="no2">NO.2</h4>
<hr>
<pre><code>#[repr(u8)]
enum Enum {
    First,
    Second,
}
</code></pre>
<p>实际为</p>
<pre><code>#[repr(u8)]
enum Enum {
    First = 0u8,
    Second = 1u8,
}
</code></pre>
<h4 id="no3">NO.3</h4>
<hr>
<pre><code>match self {
    First =&gt; print!(&quot;1&quot;),
    Second =&gt; print!(&quot;2&quot;),
}
</code></pre>
<p>这里没有指定Fisrt为Enum::First, 这里<mark>First和second都是通配符</mark>，匹配第一个就停止了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列6]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-6/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-6/">
        </link>
        <updated>2020-06-26T08:32:48.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://note.youdao.com/">原文链接</a><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">参考</a></p>
<pre><code>use std::mem;

fn main() {
    let a;
    let a = a = true;
    print!(&quot;{}&quot;, mem::size_of_val(&amp;a));
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<pre><code>//返回指向的值的大小(以字节为单位)
size_of_val
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://jgl666.github.io/post-images/1593160874878.png" alt="" loading="lazy"></figure>
<h4 id="no2">NO.2</h4>
<hr>
<p>赋值表达式<br>
<img src="https://jgl666.github.io/post-images/1593160883752.png" alt="" loading="lazy"><br>
赋值表达式由位置表达式、等号(=)和值表达式组成。这样的表达式总是具有unit类型。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列4]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-4/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-4/">
        </link>
        <updated>2020-06-26T07:53:50.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/4">原文链接</a><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">参考</a></p>
<h2 id="问题">问题</h2>
<pre><code>fn main() {
    let (.., x, y) = (0, 1, ..);
    print!(&quot;{}&quot;, b&quot;066&quot;[y][x]);
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<pre><code> let (.., x, y) = (0, 1, ..);
</code></pre>
<p>X = 1<br>Y = ..<br></p>
<pre><code>b&quot;066&quot;[..][1] = '6'
</code></pre>
<br>
<h2 id="rust相关知识点">Rust相关知识点</h2>
<p>Rust中..符号有三个含义，<a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">官方文档</a><br>
<br></p>
<ul>
<li>用作切片索引表示切割完整的数组<br>
范围：<br>
<img src="https://jgl666.github.io/post-images/1593158937516.png" alt="" loading="lazy"><br>
示例<br>
<img src="https://jgl666.github.io/post-images/1593158951682.png" alt="" loading="lazy"></li>
<li>结构体表达式<br>
结构表达式可以以语法..结尾。后跟表示函数更新的表达式。<br>
<img src="https://jgl666.github.io/post-images/1593158965905.png" alt="" loading="lazy"></li>
<li>模式匹配</li>
</ul>
<p>占位符(_)代表单个数据字段<br>
而通配符…表示特定变体的所有其余字段。<br>
<img src="https://jgl666.github.io/post-images/1593159010221.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>