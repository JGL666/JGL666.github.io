<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgl666.github.io</id>
    <title>JGL</title>
    <updated>2020-06-29T08:26:09.057Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgl666.github.io"/>
    <link rel="self" href="https://jgl666.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgl666.github.io/images/avatar.png</logo>
    <icon>https://jgl666.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JGL</rights>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列10]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-11/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-11/">
        </link>
        <updated>2020-06-29T08:25:15.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/10">原文链接</a></p>
<pre><code>trait Trait {
    fn f(&amp;self);
}

impl&lt;'a&gt; dyn Trait + 'a {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for bool {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    Trait::f(&amp;true);
    Trait::f(&amp;true as &amp;dyn Trait);
    &lt;_ as Trait&gt;::f(&amp;true);
    &lt;_ as Trait&gt;::f(&amp;true as &amp;dyn Trait);
    &lt;bool as Trait&gt;::f(&amp;true);
}
</code></pre>
<br>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>调用Trait这个trait 为bool类型实现的f方法</p>
<pre><code>Trait::f(&amp;true);
</code></pre>
<br>
示例如下
<pre><code>trait Trait1{
    fn do_something(&amp;self);
}

trait Trait2{
    fn do_something(&amp;self);
}

struct S;
impl Trait1 for S{
    fn do_something(&amp;self){
        println!(&quot;Trait1&quot;);
    }
}

impl Trait2 for S{
    fn do_something(&amp;self){
        println!(&quot;Trait2&quot;);
    }
}


fn main() {
    //Trait1
    Trait1::do_something(&amp;S);
    //Trait2
    Trait2::do_something(&amp;S);
}
</code></pre>
<br>
<h4 id="no2">NO.2</h4>
<hr>
<p>trait 对象内置的方法会被具体类型实现的方法遮蔽</p>
<pre><code>Trait::f(&amp;true as &amp;dyn Trait);
</code></pre>
<br>
<h4 id="no3">NO.3</h4>
<hr>
<p><a href="https://jgl666.github.io/post/xiao-chu-qi-yi-de-wan-quan-xian-ding-yu-fa/">消除歧义的完全限定语法</a>用来调用trait内部的关联函数或者调用指定trait实现的方法。</p>
<pre><code>&lt;_ as Trait&gt;::f(&amp;true);
//内部方法被遮蔽
&lt;_ as Trait&gt;::f(&amp;true as &amp;dyn Trait);
</code></pre>
<p>示例如下：</p>
<pre><code>trait Trait1{
    fn do_something(){
        println!(&quot;trait 1 do something&quot;)
    }
}


struct S;
impl Trait1 for S{}
impl S{
    fn do_something(){
        println!(&quot;S do something&quot;)
    }
}
fn main() {
    S::do_something();
    &lt;S as Trait1&gt;::do_something();
}
</code></pre>
<br>
<h4 id="no4">NO.4</h4>
<hr>
<p>同上</p>
<pre><code>&lt;bool as Trait&gt;::f(&amp;true);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[消除歧义的完全限定语法]]></title>
        <id>https://jgl666.github.io/post/xiao-chu-qi-yi-de-wan-quan-xian-ding-yu-fa/</id>
        <link href="https://jgl666.github.io/post/xiao-chu-qi-yi-de-wan-quan-xian-ding-yu-fa/">
        </link>
        <updated>2020-06-29T05:43:56.000Z</updated>
        <content type="html"><![CDATA[<h4 id="消除歧义的完全限定语法">消除歧义的完全限定语法</h4>
<hr>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">链接</a><br><br><br>
<strong>起因：</strong> 为同一种类型，实现不同的trait，这些trait中有同名的方法。同名的函数在调用的时候会产生歧义。</p>
<p>如下</p>
<pre><code>trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
</code></pre>
<p>上面的代码有三个重名的函数，类型自身的方法，以及 Pilot 和 Wizard 实现的方法。</p>
<p>当使用Human类型的实例调用 fly 方法的时候，默认调用自身的方法。</p>
<pre><code>fn main() {
    let person = Human;
    person.fly();
}
</code></pre>
<p>为了调用 Pilot trait 或者 wizard trait，需要显示的语法指定。</p>
<pre><code>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre>
<p>关联函数没有self参数，如下。</p>
<pre><code>trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}
</code></pre>
<br>
<p>Animal::baby_name是一个关联函数，而不是一个方法。它没有self参数，Rust不知道具体类型。<br>
<br>为了消除歧义，采用如下调用</p>
<pre><code>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre>
<p>我们为Rust提供了尖括号内的类型注释，完全限定语法格式如下</p>
<pre><code>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<p>可以在调用函数或方法的任何地方使用完全限定语法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列5]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-10/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-10/">
        </link>
        <updated>2020-06-28T13:58:28.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/5">原文链接</a></p>
<pre><code>trait Trait {
    fn p(self);
}

impl&lt;T&gt; Trait for fn(T) {
    fn p(self) {
        print!(&quot;1&quot;);
    }
}

impl&lt;T&gt; Trait for fn(&amp;T) {
    fn p(self) {
        print!(&quot;2&quot;);
    }
}

fn f(_: u8) {}
fn g(_: &amp;u8) {}

fn main() {
    let a: fn(_) = f;
    let b: fn(_) = g;
    let c: fn(&amp;_) = g;
    a.p();
    b.p();
    c.p();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>这里的T是泛型参数，编译的时候会转成具体的类型</p>
<pre><code>impl&lt;T&gt; Trait for fn(T) {
    fn p(self) {
        print!(&quot;1&quot;);
    }
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>这里涉及到对T的引用，实际是有生命周期参数</p>
<pre><code>impl&lt;T&gt; Trait for fn(&amp;T) {
    fn p(self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<p>相当于</p>
<pre><code>impl&lt;T&gt; Trait for for&lt;'a&gt; fn(&amp;'a T) {
    fn p(self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<p>表示T对应具体类型的时候，生命周期要比'a更长。</p>
<h4 id="no3">NO.3</h4>
<hr>
<pre><code>let a: fn(_) = f;
</code></pre>
<p>相当于</p>
<pre><code>let a: fn(u8) = f;
</code></pre>
<h4 id="no4">NO.4</h4>
<hr>
<pre><code>let b: fn(_) = g;
</code></pre>
<p>相当于</p>
<pre><code>let b: fn(&amp;'x u8) = g;
</code></pre>
<h4 id="no5">NO.5</h4>
<hr>
<pre><code>let c: fn(&amp;_) = g;
</code></pre>
<p>相当于</p>
<pre><code>let c: for&lt;'a&gt; fn(&amp;'a u8) = g;
</code></pre>
<br>
<h2 id="rust中相关知识">Rust中相关知识</h2>
<h3 id="hrtb">HRTB</h3>
<hr>
<p><a href="https://stackoverflow.com/questions/35592750/how-does-for-syntax-differ-from-a-regular-lifetime-bound">参考</a><br><br><br>
<a href="https://doc.rust-lang.org/nightly/nomicon/hrtb.html#higher-rank-trait-bounds-hrtbs">HRTBs</a>是Rust中一种特殊的语法。主要用在闭包上面，用来控制闭包的生命周期。<br><br>
<br></p>
<p>下面这段代码编译会失败，</p>
<pre><code>fn show&lt;'a, F&gt;(f:F) where F:Fn(&amp;'a i32)-&gt;&amp;i32{
    let v = 1;
    f(&amp;v);
}
</code></pre>
<p>img<br>
如上图所示，局部变量v的生命周期比'a要短，此时借用方的生命周期长度大于出借方，编译器报错。其实这个时候闭包还没执行，无法判断具体的生命周期参数规则（包括参数、返回值等等）。<mark>所以需要在调用的时候再判断生命周期参数</mark>。<br><br>
<br><br>
这个时候HRTBS就登场了</p>
<pre><code>fn show&lt;F&gt;(f:F) where F:for&lt;'a&gt; Fn(&amp;'a i32)-&gt;&amp;i32{
    let v = 1;
    f(&amp;v);
}
</code></pre>
<p>它告诉编译器，<mark>等在闭包调用的地方才检查生命周期规则，而不是定义的时候。因为闭包不一定引用参数作为返回值，需要根据具体调用者上下文判断。</mark></p>
<pre><code>fn filter&lt;F&gt;(self, f: F) -&gt; Option&lt;T&gt; where F: for&lt;'a&gt; FnOnce(&amp;'a T) -&gt; bool
</code></pre>
<br>
<h3 id="题目分析">题目分析</h3>
<hr>
<p>题目中</p>
<pre><code>fn g(_: &amp;u8) {}
</code></pre>
<p>应用了生命周期省略规则，实际展开应该是</p>
<pre><code>fn g&lt;'x&gt;(_: &amp;'x u8) {}
</code></pre>
<p>解析：</p>
<pre><code>let b: fn(_) = g;
    =&gt;let b:fn(_) = fn&lt;'a&gt;(_:&amp;'x u8)
        =&gt; _ = &amp;'x u8
</code></pre>
<br>
<p>题目中</p>
<pre><code>let c: fn(&amp;_) = g;
//_ 替换为u8 , &amp;后面的生命周期未知，为延迟绑定。匹配for&lt;'a&gt; fn(&amp;'a x)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列9]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-9/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-9/">
        </link>
        <updated>2020-06-26T09:08:06.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/9">原文链接</a><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">参考</a></p>
<pre><code>macro_rules! m {
    (1) =&gt; { print!(&quot;1&quot;) };
    ($tt:tt) =&gt; { print!(&quot;2&quot;) };
}

macro_rules! e {
    ($e:expr) =&gt; { m!($e) };
}

macro_rules! t {
    ($tt:tt) =&gt; { e!($tt); m!($tt); };
}

fn main() {
    t!(1);
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>e!(1)扩展为m!(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>)</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi></mrow><annotation encoding="application/x-tex">e)，其中</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span></span></span></span>e是包含1的不透明表达式。它不会匹配字面量，只会匹配tt类型或者expr类型</p>
<pre><code>macro_rules! e {
    ($e:expr) =&gt; { m!($e) };
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<pre><code>macro_rules! m {
    (1) =&gt; { print!(&quot;1&quot;) };
    ($tt:tt) =&gt; { print!(&quot;2&quot;) };
}
</code></pre>
<p>为什么expr 可以匹配到 tt<br><br>
tt 是token类型，可以匹配任何类型，因为token包含一切符号。<br><br>
详见<a href="https://stackoverflow.com/questions/40302026/what-does-the-tt-metavariable-type-mean-in-rust-macros">链接</a></p>
<blockquote>
<p>Token tree is the least demanding metavariable type: it matches anything. It's often used in macros which have a “don't really care” part, and especially in macros which have a “head” and a “tail” part. For example, the println! macros have a branch matching ($fmt:expr, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo></mrow><annotation encoding="application/x-tex">(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span></span></span></span>arg:tt)<em>) where $fmt is the format string, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo></mrow><annotation encoding="application/x-tex">(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span></span></span></span>arg:tt)</em> means “all the rest” and is just forwarded to format_args!. Which means that println! does not need to know the actual format and do complicated matching with it.</p>
</blockquote>
<p>如果变成下面的宏，就会匹配expr</p>
<pre><code>macro_rules! m {
    (1) =&gt; { print!(&quot;1&quot;) };
    ($e:expr) =&gt; { print!(&quot;3&quot;) };
    ($tt:tt) =&gt; { print!(&quot;2&quot;) };
}
</code></pre>
<h2 id="rust相关知识">Rust相关知识</h2>
<p>不透明词条树 : 不能匹配字面量的词条树<br><br>
以下是不透明词条类型</p>
<pre><code>$:block
$:expr
$:item
$:literal
$:meta
$:pat
$:path
$:stmt
$:ty
</code></pre>
<p>透明词条类型</p>
<pre><code>$:ident
$:lifetime
$:tt
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列8]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-8/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-8/">
        </link>
        <updated>2020-06-26T08:49:30.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/8">原文链接</a><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">参考</a></p>
<pre><code>macro_rules! m {
    (==&gt;) =&gt; { print!(&quot;1&quot;); };
    (= = &gt;) =&gt; { print!(&quot;2&quot;); };
    (== &gt;) =&gt; { print!(&quot;3&quot;); };
    (= =&gt;) =&gt; { print!(&quot;4&quot;); };
}

fn main() {
    m!(==&gt;);
    m!(= = &gt;);
    m!(== &gt;);
    m!(= =&gt;);
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<pre><code> (==&gt;) =&gt; { print!(&quot;1&quot;); };
</code></pre>
<p>这个符号Rust中不存在，按照贪心算法，== 被分为一组，&gt;被分为一组</p>
<pre><code>m!(==&gt;);
m!(== &gt;);
</code></pre>
<p>这两个都会分组为（==） 和 (&gt;)</p>
<h4 id="no2">NO.2</h4>
<hr>
<pre><code>m!(= = &gt;);
</code></pre>
<p>没什么好说的，三个组分别是(=)、(=)、(&gt;)</p>
<h4 id="no3">NO3</h4>
<hr>
<pre><code>(= =&gt;) =&gt; { print!(&quot;4&quot;); };
</code></pre>
<p>没什么好说的，三个组分别是=)、(=&gt;)</p>
<h2 id="rust相关知识">Rust相关知识</h2>
<p>标点符号在macro_rules宏中会根据Rust中标点符号分组。</p>
<pre><code>=&lt;&lt;
</code></pre>
<p>Rust的宏将=&lt;&lt;分组，分组依据是Rust中<a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">标点符号</a>，根据贪心算法先取=, 后面的&lt;&lt;，遇到&lt;是一个符号，&lt;&lt;也是一个符号，就将&lt;&lt; 作为一个符号分组</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列7]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-7/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-7/">
        </link>
        <updated>2020-06-26T08:43:06.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/7">原文链接</a><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">参考</a></p>
<pre><code>
#[repr(u8)]
enum Enum {
    First,
    Second,
}

impl Enum {
    fn p(self) {
        match self {
            First =&gt; print!(&quot;1&quot;),
            Second =&gt; print!(&quot;2&quot;),
        }
    }
}

fn main() {
    Enum::p(unsafe {
        std::mem::transmute(1u8)
    });
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>将一种类型的值的位重新解释为另一种类型。这两种类型必须具有相同的大小</p>
<pre><code>std::mem::transmute(1u8)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://jgl666.github.io/post-images/1593161323734.png" alt="" loading="lazy"></figure>
<h4 id="no2">NO.2</h4>
<hr>
<pre><code>#[repr(u8)]
enum Enum {
    First,
    Second,
}
</code></pre>
<p>实际为</p>
<pre><code>#[repr(u8)]
enum Enum {
    First = 0u8,
    Second = 1u8,
}
</code></pre>
<h4 id="no3">NO.3</h4>
<hr>
<pre><code>match self {
    First =&gt; print!(&quot;1&quot;),
    Second =&gt; print!(&quot;2&quot;),
}
</code></pre>
<p>这里没有指定Fisrt为Enum::First, 这里<mark>First和second都是通配符</mark>，匹配第一个就停止了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列6]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-6/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-6/">
        </link>
        <updated>2020-06-26T08:32:48.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://note.youdao.com/">原文链接</a><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">参考</a></p>
<pre><code>use std::mem;

fn main() {
    let a;
    let a = a = true;
    print!(&quot;{}&quot;, mem::size_of_val(&amp;a));
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<pre><code>//返回指向的值的大小(以字节为单位)
size_of_val
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://jgl666.github.io/post-images/1593160874878.png" alt="" loading="lazy"></figure>
<h4 id="no2">NO.2</h4>
<hr>
<p>赋值表达式<br>
<img src="https://jgl666.github.io/post-images/1593160883752.png" alt="" loading="lazy"><br>
赋值表达式由位置表达式、等号(=)和值表达式组成。这样的表达式总是具有unit类型。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列4]]></title>
        <id>https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-4/</id>
        <link href="https://jgl666.github.io/post/quiz-yue-du-bi-ji-xi-lie-4/">
        </link>
        <updated>2020-06-26T07:53:50.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/4">原文链接</a><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">参考</a></p>
<h2 id="问题">问题</h2>
<pre><code>fn main() {
    let (.., x, y) = (0, 1, ..);
    print!(&quot;{}&quot;, b&quot;066&quot;[y][x]);
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<pre><code> let (.., x, y) = (0, 1, ..);
</code></pre>
<p>X = 1<br>Y = ..<br></p>
<pre><code>b&quot;066&quot;[..][1] = '6'
</code></pre>
<br>
<h2 id="rust相关知识点">Rust相关知识点</h2>
<p>Rust中..符号有三个含义，<a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">官方文档</a><br>
<br></p>
<ul>
<li>用作切片索引表示切割完整的数组<br>
范围：<br>
<img src="https://jgl666.github.io/post-images/1593158937516.png" alt="" loading="lazy"><br>
示例<br>
<img src="https://jgl666.github.io/post-images/1593158951682.png" alt="" loading="lazy"></li>
<li>结构体表达式<br>
结构表达式可以以语法..结尾。后跟表示函数更新的表达式。<br>
<img src="https://jgl666.github.io/post-images/1593158965905.png" alt="" loading="lazy"></li>
<li>模式匹配</li>
</ul>
<p>占位符(_)代表单个数据字段<br>
而通配符…表示特定变体的所有其余字段。<br>
<img src="https://jgl666.github.io/post-images/1593159010221.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列3]]></title>
        <id>https://jgl666.github.io/post/quiz12/</id>
        <link href="https://jgl666.github.io/post/quiz12/">
        </link>
        <updated>2020-06-26T06:47:44.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/3">原文链接</a><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">参考</a></p>
<h2 id="问题">问题</h2>
<pre><code>struct S {
    x: i32,
}

const S: S = S { x: 2 };

fn main() {
    let v = &amp;mut S;
    v.x += 1;
    S.x += 1;
    print!(&quot;{}{}&quot;, v.x, S.x);
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p><a href="https://doc.rust-lang.org/reference/items/constant-items.html">常量表达式</a>在使用时本质上是内联的，这意味着它们在使用时直接复制到相关的上下文中。<mark>对相同常量的引用不一定保证引用相同的内存地址</mark>。（相等于宏定义）<br><br>
常量必须显式类型。类型必须具有静态生存期。</p>
<pre><code>const S: S = S { x: 2 };
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>引用类型的任何名称都存在于<mark>类型名称空间</mark>中，引用值的任何名称都存在于<mark>值名称空间中</mark>。<br>这是<mark>两组独立的名称</mark>，该语言的结构使我们总是能够知道在哪个名称空间中查找名称。<br></p>
<p>这是在类型空间</p>
<pre><code>struct S {
    x: i32,
}
</code></pre>
<p>这是在值空间</p>
<pre><code>const S: S = S { x: 2 };
</code></pre>
<h4 id="no3">NO.3</h4>
<hr>
<pre><code>let v = &amp;mut S;
v.x += 1;
</code></pre>
<p>相当于</p>
<pre><code>let mut _tmp0 = S { x: 2 };
let v = &amp;mut _tmp0;
</code></pre>
<h4 id="no4">NO.4</h4>
<hr>
<pre><code>S.x += 1;
</code></pre>
<p>拓展成</p>
<pre><code>S { x: 2 }.x += 1;
</code></pre>
<h4 id="no5">NO.5</h4>
<hr>
<pre><code>print!(&quot;{}{}&quot;, v.x, S.x);
</code></pre>
<p>拓展成</p>
<pre><code> print!(&quot;{}{}&quot;, v.x, S { x: 2 }.x);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列2]]></title>
        <id>https://jgl666.github.io/post/quiz/</id>
        <link href="https://jgl666.github.io/post/quiz/">
        </link>
        <updated>2020-06-26T06:40:45.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/2">原文链接</a><br>
<a href="https://zhuanlan.zhihu.com/p/101354383">参考</a></p>
<h2 id="问题br">问题<br></h2>
<pre><code>struct S(i32);

impl std::ops::BitAnd&lt;S&gt; for () {
    type Output = ();

    fn bitand(self, rhs: S) {
        print!(&quot;{}&quot;, rhs.0);
    }
}

fn main() {
    let f = || ( () &amp; S(1) );
    let g = || { () &amp; S(2) };
    let h = || ( {} &amp; S(3) );
    let i = || { {} &amp; S(4) };
    f();
    g();
    h();
    i();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>（）是分组表达式，结果是整个括号内部计算的结果，是一条表达式语句。<br><br>
闭包返回的是一个分组表达式，计算结果为括号内部的计算结果。即调用bitand输出1</p>
<pre><code> let f = || ( () &amp; S(1) );
</code></pre>
<br>
<h4 id="no2">NO.2</h4>
<hr>
<p>块表达式语句中只有一条表达式语句，计算结果就是() &amp; S(2)结果，即调用bitand输出2</p>
<pre><code> let g = || { () &amp; S(2) };
</code></pre>
<br>
<h4 id="no3">NO.3</h4>
<hr>
<p>闭包返回一个<a href="https://doc.rust-lang.org/reference/expressions/grouped-expr.html">分组表达式</a>。</p>
<pre><code>let h = || ( {} &amp; S(3) );
</code></pre>
<p>拿掉外面的()，计算如下表达式</p>
<pre><code> {} &amp; S(3)
</code></pre>
<p>因为{}是一个块表达式，默认返回单元类型(),所以最终相当于计算</p>
<pre><code>() &amp; S(3)
</code></pre>
<p>最后输出3</p>
<br>
<h4 id="no4">NO.4</h4>
<hr>
<p>闭包返回的是块表达式，块表达式是按顺序执行表达式中的语句。</p>
<pre><code> let i = || { {} &amp; S(4) };
</code></pre>
<p>该块表达式一共有两条语句，一条是{}<a href="https://doc.rust-lang.org/reference/expressions/block-expr.html">块表达式语句</a>，另一条是<a href="https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions">位置表达式语句</a>。因为是块表达式的最后一句，作为块表达式的返回值，<mark>本来表达式作为语句需要加分号，现在不用加了</mark>。<br><br>
所以执行流程如下</p>
<pre><code>let i = || { 
{};
return &amp;S(4); };
</code></pre>
<p>最后返回&amp;S(4),什么输出也没有。</p>
<br>
<h2 id="rust相关知识点">Rust相关知识点</h2>
<ul>
<li>
<p><strong>关联类型</strong><br><br>
关联类型是一个占位符，trait在方法签名的时候，暂时使用它来表示抽象的类型，<br>
等到具体实现的时候指定具体的类型。<br></p>
<p><strong>和泛型比较：</strong><br><br>
   <strong>相同</strong>：关联类型和泛型一样都是延迟对trait使用具体类型的决定。<br><br>
   <strong>不同</strong>：当一个trait有一个泛型参数时，它可以为一个类型实现多次，每次更改泛型类型参数的具体类型。关联类型只能实现一次。<br></p>
</li>
</ul>
<p>   <strong>泛型示例</strong></p>
<pre><code>impl From&lt;(i32,i32)&gt; for Pointer{
    fn from(val:(i32,i32))-&gt;Pointer{
        Pointer{x:val.0, y:val.1}
    }
}


impl From&lt;i32&gt; for Pointer{
    fn from(val:i32)-&gt;Pointer{
        Pointer{x:val, y:val}
    }
}
</code></pre>
<p>   <strong>关联类型示例</strong></p>
<pre><code>impl Iterator for Pointer{
    type Item = i32;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;{
        None
    }
}
</code></pre>
]]></content>
    </entry>
</feed>