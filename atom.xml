<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgl666.github.io</id>
    <title>JGL</title>
    <updated>2020-07-07T09:41:00.357Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgl666.github.io"/>
    <link rel="self" href="https://jgl666.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgl666.github.io/images/avatar.png</logo>
    <icon>https://jgl666.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, JGL</rights>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列21]]></title>
        <id>https://jgl666.github.io/post/ccc/</id>
        <link href="https://jgl666.github.io/post/ccc/">
        </link>
        <updated>2020-07-07T09:40:44.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/21">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<hr>
<pre><code>trait Trait {
    fn f(&amp;self);
}

impl&lt;F: FnOnce() -&gt; bool&gt; Trait for F {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for () {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let x = || { (return) || true; };
    x().f();

    let x = loop { (break) || true; };
    x.f();

    let x = || { return (|| true); };
    x().f();

    let x = loop { break (|| true); };
    x.f();

    let x = || { return || true; };
    x().f();

    let x = loop { break || true; };
    x.f();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>这个闭包返回(),因为(return) || true;return 是never类型, 即！可以转换为任何类型，这里会转为bool。最后， 这是一个表达式语句，外面是块表达式，最后返回（）</p>
<pre><code>let x = || { (return) || true; };
x().f();
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>这里break 跳出循环，隐式返回（）</p>
<pre><code>let x = loop { (break) || true; };
x.f();
</code></pre>
<h4 id="no3">NO.3</h4>
<p>return 返回闭包</p>
<pre><code>let x = || { return (|| true); };
x().f();
</code></pre>
<h4 id="no4">NO.4</h4>
<p>括号的优先级大于break，执行括号表达式，break 返回闭包</p>
<pre><code>let x = loop { break (|| true); };
x.f();

</code></pre>
<h4 id="no5">NO.5</h4>
<p>返回闭包</p>
<pre><code>let x = || { return || true; };
x().f();
</code></pre>
<h4 id="no6">NO.6</h4>
<p>返回闭包</p>
<pre><code>let x = loop { break || true; };
x.f();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列20]]></title>
        <id>https://jgl666.github.io/post/zzzz/</id>
        <link href="https://jgl666.github.io/post/zzzz/">
        </link>
        <updated>2020-07-07T09:38:03.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/20">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>fn return1() {
    if (return { print!(&quot;1&quot;) }) {
    }
}

fn return2() {
    if return { print!(&quot;2&quot;) } {
    }
}

fn break1() {
    loop {
        if (break { print!(&quot;1&quot;) }) {
        }
    }
}

fn break2() {
    loop {
        if break { print!(&quot;2&quot;) } {
        }
    }
}

fn main() {
    return1();
    return2();
    break1();
    break2();
}
</code></pre>
<h2 id="解析">解析</h2>
<p>参照<a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">表达式优先级</a><br></p>
<h4 id="no1">NO.1</h4>
<hr>
<p>return 总是优化处理后面的表达式</p>
<pre><code>fn return1() {
    if (return { print!(&quot;1&quot;) }) {
    }
}

fn return2() {
    if return { print!(&quot;2&quot;) } {
    }
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>() 优先级大于break，先计算括号表达式，输出1</p>
<pre><code>fn break1() {
    loop {
        if (break { print!(&quot;1&quot;) }) {
        }
    }
}
</code></pre>
<h4 id="no3">NO.3</h4>
<pre><code>fn break2() {
    loop {
        if break { print!(&quot;2&quot;) } {
        }
    }
}
</code></pre>
<p>和return 不一样，break不优先处理后面的表达式，上面的函数格式化如下。break在 {println!(&quot;2&quot;)} 之前就退出了。</p>
<pre><code>fn break2() {
    loop {
        if break
        { print!(&quot;2&quot;) }
        {}
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列19]]></title>
        <id>https://jgl666.github.io/post/aaa/</id>
        <link href="https://jgl666.github.io/post/aaa/">
        </link>
        <updated>2020-07-07T09:36:54.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/19">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>struct S;

impl Drop for S {
    fn drop(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let s = S;
    let _ = s;
    print!(&quot;2&quot;);
}
</code></pre>
<h2 id="解析">解析</h2>
<p>所有权发生转移</p>
<pre><code>let s = S;
</code></pre>
<p>所有权没有接收者，s会一直存在直到作用域结束</p>
<pre><code> let _ = s;
</code></pre>
<h4 id="拓展">拓展</h4>
<p>输出112，因为所有权没有接收者，直接drop了</p>
<pre><code>struct S;

impl Drop for S {
    fn drop(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

fn get()-&gt;S{
    S
}

fn main() {
    let _ = get();
    let _ = S;
    print!(&quot;2&quot;);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列18]]></title>
        <id>https://jgl666.github.io/post/sss/</id>
        <link href="https://jgl666.github.io/post/sss/">
        </link>
        <updated>2020-07-07T09:30:22.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/18">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>struct S {
    f: fn(),
}

impl S {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let print2 = || print!(&quot;2&quot;);
    S { f: print2 }.f();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>访问内部方法</p>
<pre><code>S { f: print2 }.f();
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>加括号显式调用闭包</p>
<pre><code> (S { f: print2 }).f();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列16和17]]></title>
        <id>https://jgl666.github.io/post/sssss/</id>
        <link href="https://jgl666.github.io/post/sssss/">
        </link>
        <updated>2020-07-07T09:12:45.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/16">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<h2 id="16">16</h2>
<pre><code>fn main() {
    let mut x = 4;
    --x;
    print!(&quot;{}{}&quot;, --x, --x);
}
</code></pre>
<p>相当于</p>
<pre><code>print!(&quot;{}{}&quot;, -(-x), -(-x));
</code></pre>
<h2 id="17">17</h2>
<p>Rust中没有--</p>
<pre><code>fn main() {
    let mut a = 5;
    let mut b = 3;
    print!(&quot;{}&quot;, a-- - --b);
}
</code></pre>
<p>上面相当于</p>
<pre><code>    let mut a = 5;
    let mut b = 3;
    print!(&quot;{}&quot;, a-(-(-(-(-b)))));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列23]]></title>
        <id>https://jgl666.github.io/post/ssss/</id>
        <link href="https://jgl666.github.io/post/ssss/">
        </link>
        <updated>2020-07-07T09:11:41.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/23">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<hr>
<pre><code>trait Trait {
    fn f(&amp;self);
    fn g(&amp;self);
}

struct S;

impl S {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }

    fn g(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for S {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }

    fn g(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    S.f();
    S.g();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>如果结构体方法和trait中方法重名，默认调用结构体自身的方法。可以使用消除歧义的语法调用trait中的方法。</p>
<pre><code>&lt;S as Trait&gt;::f(&amp;S);
</code></pre>
<p>NO.2</p>
<hr>
<p>S找不到方法，会添加引用，找到Trait中定义的方法</p>
<pre><code>fn g(&amp;self) {
    print!(&quot;2&quot;);
}
</code></pre>
<h4 id="no3">NO.3</h4>
<hr>
<p>如果还是找不到就加上&amp;mut<br>
这里注释掉，输出11</p>
<pre><code>impl Trait for S {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }

    fn g(&amp;self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<h4 id="no4">NO.4</h4>
<hr>
<p>增加新的Trait1，输出33，因为直接匹配到方法中接受类型就是S</p>
<pre><code>trait Trait1{
    fn f(self);
    fn g(self);
}

impl Trait1 for S {
    fn f(self) {
        print!(&quot;3&quot;);
    }

    fn g(self) {
        print!(&quot;3&quot;);
    }
}
</code></pre>
<h4 id="no5">NO.5</h4>
<hr>
<p>这样也可以，输出1，3</p>
<pre><code>trait Trait {
    fn f(&amp;self);
    fn g(&amp;self);
}

struct S;

impl S {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }

    fn g(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

// impl Trait for S {
//     fn f(&amp;self) {
//         print!(&quot;2&quot;);
//     }
//
//     fn g(&amp;self) {
//         print!(&quot;2&quot;);
//     }
// }

trait Trait1{
    fn f(self);
    fn g(self);
}

impl Trait1 for &amp;S {
    fn f(self) {
        print!(&quot;3&quot;);
    }

    fn g(self) {
        print!(&quot;3&quot;);
    }
}
fn main() {
    S.f();
    S.g();
}
</code></pre>
<h4 id="no5-2">NO.5</h4>
<hr>
<p>这里输出33，没找到先解引用</p>
<pre><code>trait Trait {
    fn f(&amp;self);
    fn g(&amp;self);
}

struct S;

// impl S {
//     fn f(&amp;self) {
//         print!(&quot;1&quot;);
//     }
//
//     fn g(&amp;mut self) {
//         print!(&quot;1&quot;);
//     }
// }

impl Trait for S {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }

    fn g(&amp;self) {
        print!(&quot;2&quot;);
    }
}

trait Trait1{
    fn f(self);
    fn g(self);
}

impl Trait1 for S {
    fn f(self) {
        print!(&quot;3&quot;);
    }

    fn g(self) {
        print!(&quot;3&quot;);
    }
}
fn main() {
    &amp;S.f();
    &amp;S.g();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列31]]></title>
        <id>https://jgl666.github.io/post/xxafaba/</id>
        <link href="https://jgl666.github.io/post/xxafaba/">
        </link>
        <updated>2020-07-04T07:21:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="原文链接"><a href="https://dtolnay.github.io/rust-quiz/31">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a><br><br>
<a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html#method-call-expressions">相关文档</a></h2>
<pre><code>trait Or {
    fn f(self);
}

struct T;

impl Or for &amp;T {
    fn f(self) {
        print!(&quot;1&quot;);
    }
}

impl Or for &amp;&amp;&amp;&amp;T {
    fn f(self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let t = T;
    let wt = &amp;T;
    let wwt = &amp;&amp;T;
    let wwwt = &amp;&amp;&amp;T;
    let wwwwt = &amp;&amp;&amp;&amp;T;
    let wwwwwt = &amp;&amp;&amp;&amp;&amp;T;
    t.f();
    wt.f();
    wwt.f();
    wwwt.f();
    wwwwt.f();
    wwwwwt.f();
}
</code></pre>
<h2 id="解析">解析</h2>
<h4 id="no1">NO.1</h4>
<hr>
<p>尝试寻找T对应的f方法，没有找到，然后给T加上&amp;，找到对应的方法</p>
<pre><code>let t = T;
t.f();
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>直接找到对应的类型&amp;T</p>
<pre><code>let wt = &amp;T;
wt.f();
</code></pre>
<h4 id="no3">NO.3</h4>
<hr>
<p>找到对应的类型&amp;&amp;T,没找到,加上&amp;,还是没有，然后解引用，找到&amp;T</p>
<pre><code>let wwt = &amp;&amp;T;
wwt.f();
</code></pre>
<h4 id="no4">NO.4</h4>
<hr>
<p>找到对应的类型&amp;&amp;&amp;T,没找到,加上&amp;,找到 &amp;&amp;&amp;&amp;T</p>
<pre><code>let wwwt = &amp;&amp;&amp;T;
wwwt.f();
</code></pre>
<h4 id="no5">NO.5</h4>
<hr>
<p>找到对应的类型&amp;&amp;&amp;T,没找到,加上&amp;,没找到,解引用找到</p>
<pre><code>let wwwwt = &amp;&amp;&amp;&amp;T;
wwwwt.f();
</code></pre>
<h4 id="no6">NO.6</h4>
<hr>
<p>找到对应的类型&amp;&amp;&amp;&amp;&amp;T,没找到,加上&amp;, 没找到,解引用找到</p>
<pre><code>let wwwwwt = &amp;&amp;&amp;&amp;&amp;T;
wwwwwt.f();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列32]]></title>
        <id>https://jgl666.github.io/post/xx/</id>
        <link href="https://jgl666.github.io/post/xx/">
        </link>
        <updated>2020-07-02T14:58:41.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/32">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<hr>
<pre><code>fn check(x: i32) -&gt; bool {
    print!(&quot;{}&quot;, x);
    false
}

fn main() {
    match (1, 2) {
        (x, _) | (_, x) if check(x) =&gt; {
            print!(&quot;3&quot;)
        }
        _ =&gt; print!(&quot;4&quot;),
    }
}
</code></pre>
<h2 id="解析">解析</h2>
<p>参看<a href="https://doc.rust-lang.org/reference/expressions/match-expr.html#match-guards">match guard</a><br><br>
上面这题的匹配过程：<br>
Rust match 匹配到 <mark>(x , _)</mark> ，此时x = 1, 然后执行 if 判断，check(x) 输出 1 , 返回false , Rust 继续匹配，匹配到 <mark>( _ , x)</mark>， 此时x = 2，再次执行 if 判断语句，返回false。继续匹配下面一条，因为 _ 是通配符，所以输出4<br><br>
流程如下图：<br>
<img src="https://jgl666.github.io/post-images/1593701933236.PNG" alt="" loading="lazy"><br>
<br></p>
<h2 id="拓展">拓展</h2>
<p>改为true 输出1 3</p>
<pre><code>fn check(x: i32) -&gt; bool {
    print!(&quot;{}&quot;, x);
    true
}

fn main() {
    match (1, 2) {
        (x, _) | (_, x) if check(x) =&gt; {
            print!(&quot;3&quot;)
        }
        _ =&gt; print!(&quot;4&quot;),
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ quiz阅读笔记系列20]]></title>
        <id>https://jgl666.github.io/post/s/</id>
        <link href="https://jgl666.github.io/post/s/">
        </link>
        <updated>2020-07-02T05:04:42.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/15">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>fn return1() {
    if (return { print!(&quot;1&quot;) }) {
    }
}

fn return2() {
    if return { print!(&quot;2&quot;) } {
    }
}

fn break1() {
    loop {
        if (break { print!(&quot;1&quot;) }) {
        }
    }
}

fn break2() {
    loop {
        if break { print!(&quot;2&quot;) } {
        }
    }
}

fn main() {
    return1();
    return2();
    break1();
    break2();
}
</code></pre>
<h2 id="解析">解析</h2>
<p>参照<a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">表达式优先级</a><br></p>
<h4 id="no1">NO.1</h4>
<hr>
<p>return 总是优化处理后面的表达式</p>
<pre><code>fn return1() {
    if (return { print!(&quot;1&quot;) }) {
    }
}

fn return2() {
    if return { print!(&quot;2&quot;) } {
    }
}
</code></pre>
<h4 id="no2">NO.2</h4>
<hr>
<p>() 优先级大于break，先计算括号表达式，输出1</p>
<pre><code>fn break1() {
    loop {
        if (break { print!(&quot;1&quot;) }) {
        }
    }
}
</code></pre>
<h4 id="no3">NO.3</h4>
<pre><code>fn break2() {
    loop {
        if break { print!(&quot;2&quot;) } {
        }
    }
}
</code></pre>
<p>和return 不一样，break不优先处理后面的表达式，上面的函数格式化如下。break在 {println!(&quot;2&quot;)} 之前就退出了。</p>
<pre><code>fn break2() {
    loop {
        if break
        { print!(&quot;2&quot;) }
        {}
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[quiz阅读笔记系列15]]></title>
        <id>https://jgl666.github.io/post/xxx/</id>
        <link href="https://jgl666.github.io/post/xxx/">
        </link>
        <updated>2020-07-01T08:04:28.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://dtolnay.github.io/rust-quiz/15">原文链接</a><br><br>
<a href="https://zhuanlan.zhihu.com/p/52098828">Rust Quiz 解读汇总</a></p>
<pre><code>trait Trait {
    fn f(&amp;self);
}

impl Trait for u32 {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

impl&lt;'a&gt; Trait for &amp;'a i32 {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let x = &amp;0;
    x.f();
}
</code></pre>
<h2 id="解析">解析</h2>
<p>原理详见<a href="https://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules/28552082#28552082">stackoverflow</a><br></p>
<p>给出了方法解引用步骤</p>
<blockquote>
<p>The core of the algorithm is:</p>
<p>For each &quot;dereference step&quot; U (that is, set U = T and then U = *T, ...)<br><br>
1、if there's a method bar where the receiver type (the type of self in the method) matches U exactly , use it (a &quot;by value method&quot;)<br><br>
2、otherwise, add one auto-ref (take &amp; or &amp;mut of the receiver), and, if some method's receiver matches &amp;U, use it (an &quot;autorefd method&quot;)</p>
</blockquote>
<p>对于上面这题两个trait 实现，这里u32和&amp;u32是两个类型。</p>
<pre><code>impl Trait for u32 
impl&lt;'a&gt; Trait for &amp;'a i32
</code></pre>
<p>现在应用上面的规则：<br><br>
对于</p>
<pre><code>let x = &amp;0;
</code></pre>
<p>此时U为&amp;x，完全匹配方法f的参数类型&amp;self。适用于第一条规则。</p>
<pre><code>//等同于fn f(&amp;u32)
fn f(&amp;self) {
    print!(&quot;1&quot;);
}
</code></pre>
<p>如果这个时候注释掉</p>
<pre><code>impl Trait for u32 {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}
</code></pre>
<p>此时第一条规则不成立，尝试第二条规则，给类型自动加引用。此时x的类型如下：</p>
<pre><code>x: &amp;&amp;u32
</code></pre>
<p>因为针对&amp;u32有实现的trait</p>
<pre><code>impl&lt;'a&gt; Trait for &amp;'a i32 {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<p>此时self 为&amp; &amp;u32,而x为&amp; &amp;u32, 满足参数类型。所以输出2。</p>
<h2 id="拓展">拓展</h2>
<pre><code>trait Trait {
    fn f(&amp;self);
}

impl&lt;'a&gt; Trait for &amp;'a i32 {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

impl&lt;'a&gt; Trait for &amp;'a &amp;i32 {
    fn f(&amp;self) {
        print!(&quot;3&quot;);
    }
}

fn main() {
    let x = &amp;&amp;0;
    x.f();
}
</code></pre>
<p>上面代码输出2<br></p>
<hr>
<p>当注释掉</p>
<pre><code>impl&lt;'a&gt; Trait for &amp;'a i32 {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}
</code></pre>
<p>输出3<br><br>
原理同上</p>
]]></content>
    </entry>
</feed>